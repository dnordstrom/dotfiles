#!/usr/bin/env sh
#
# RIVER CONFIGURATION
#
# River is a tiling window manager for Wayland, configurable in any language via the `riverctl`
# executable and a layout generator (currently using the default `rivertile`).
#
# Let's stick with shell scripts for now but switch to Lua or Python as soon as it gets more
# complex. Or why not Go or Rust just for the fun of it, could be a simple learning experience (at
# the expense of having to recompile to test it).
##

##
# STUFF THAT CONSIDERS ITSELF IMPORTANT
##

export NX_RTILE_LOGFILE="$HOME/.local/share/logs/rivertile.log"

##
# UTILITIES
##

# Spawn process, forwarding any arguments to `riverctl`. Jusr some premature preparation in case we
# want to do something cool and convenient in the future.
#
# Example     $ riverctl spawn $(shell_command "systemctl --user enable cool.service && nvim README.md")
#     = riverctl spawn zsh -c 'systemctl --user enable cool.service && nvim README.md'
#
# arguments:
#   - $* - any arguments are passed to the shell as command to run, as printed by `printf`.
#
# Returns:
#   - In terminal context, outputs shell command to standard output.
#   - In non-terminal contexts (e.g. piped to from another command), return the shell command.
#
# Globals:
#   - SHELL is used as the shell to launch. Until threre's a flag, it can be changed there:
#     `SHELL=zsh echo "$(shell_command echo Hello, dear world.)"`
nx_rctl_spawn() {
  riverctl spawn "$*"
}

# Spawn only if no running process was spawned with the same exact command.
nx_rctl_spawn_once() {
  pgrep -f "$*" >/dev/null || riverctl spawn "$*"
}

# Spawn in shell, avoiding boilerplate when using multiple commands, piping, etc.
nx_rctl_spawn_shell() {
  riverctl spawn "sh -c '$*'"
}

# Map the Escape, Return, and Space keys to exit given mode. If no mode is passed to the function,
# then it notifies and/or logs it depending on settings, since it has no value it can default to.
#
# Arguments:
#   - $* - Name of the mode we want to add exit maps for.
nx_rctl_add_mode_exit_maps() {
  riverctl map "$1" None Escape enter-mode normal
  riverctl map "$1" None Return enter-mode normal
  riverctl map "$1" None Space enter-mode normal
}

##
# VARIABLES
##

# Paths.
export NX_KITTY_SESSIONS="$HOME/.config/kitty/sessions"

# Look and feel (also known as layout manager options.
export NX_RTILE_MAIN_RATIO=0.5
export NX_RTILE_MAIN_COUNT=1
export NX_RTILE_MAIN_LOCATION="left"
export NX_RTILE_VIEW_PADDING=10
export NX_RTILE_OUTER_PADDING=10

# Tags.
export NX_RIVER_TAGS_ALL="$(((1 << 32) - 1))"
export NX_RIVER_TAGS_STICKY="$((1 << 20))"
export NX_RIVER_TAGS_SCRATCHPAD="$((1 << 21))"
export NX_RIVER_TAGS_NONSTICKY="$((NX_RIVER_TAGS_ALL ^ NX_RIVER_TAGS_STICKY))"
export NX_RIVER_TAGS_NONSCRATCHPAD="$((NX_RIVER_TAGS_ALL ^ NX_RIVER_TAGS_SCRATCHPAD))"
export NX_RIVER_TAGS_NONSPECIAL="$((NX_RIVER_TAGS_NONSTICKY ^ NX_RIVER_TAGS_NONSCRATCHPAD))"

# Terminal startup sessions for using different layouts and init commands, literally does anything.
cmd_terminal_plain="kitty --class=plainterm --title Plain"
cmd_terminal_scratchpad="kitty --class=scratchterm --title 'Scratchpad terminal' --single-instance --instance-group scratchterm --session \"$NX_KITTY_SESSIONS/scratchpad.session\""
cmd_terminal_popup="kitty --class=popupterm --title='Popup terminal' --single-instance --instance-group=popupterm"
cmd_terminal_trans="kitty --class=transterm --title='Transparent terminal'"

# Launchers.
cmd_launch_app="/etc/nixos/scripts/launch/launchapp"
cmd_launch_cmd="/etc/nixos/scripts/launch/launchcommand"
cmd_launch_gui="rofi -show drun"

# File managers. Choice is hard. Luckily choice is just an illusion anyway. Free will is just a
# naive perspective that puts us in control, when reality is a game of dominoes and all we can do is
# watch the dominoes fall, each a direct consequence of the previous and direct cause of the next.
cmd_files_qt="dolphin"
cmd_files_gtkone="nemo"
cmd_files_gtktwo="nautilus"
cmd_files_tui="$cmd_terminal_popup -e vifm"

##
# SETTINGS
##

#
# Behavior
#

# Set to `normal` to not refocus if another view has been explicitly focused.
riverctl focus-follows-cursor normal

#
# Colors and borders
#

riverctl background-color 0x002b36
riverctl border-color-focused 0x93a1a1
riverctl border-color-unfocused 0x586e75
riverctl border-width 2

##
# INPUTS
##

#
# Keyboards
#

riverctl set-repeat 35 250

# Device IDs from `riverctl list-inputs`.
#
# NOTE: I'd recommend just concatenating device IDs directly to the single `keebs` variable, but
# that's no fun.
keeb_ducky="keyboard-12851-25345-Ducky_Ducky_One2_Mini_RGB"
keeb_havit="keyboard-1452-591-KB496L"
keeb_das="keyboard-9456-322-Metadot_-_Das_Keyboard_D4269"
keeb_vortex="keyboard-1241-519-USB-HID_Keyboard"

# Keyboard features like layered system, media, and mouse keys.
keeb_das="${keeb_das} ${keeb_das}_Consumer_Control  ${keeb_das}_System_Control"
keeb_vortex="${keeb_vortex} ${keeb_vortex}_Consumer_Control ${keeb_vortex}_System_Control"

# Concatenate all keyboards and separate by newline instead of space.
keebs="$keeb_das $keeb_ducky $keeb_vortex $keeb_havit"
keebs="$(printf '%s' "$keebs" | tr '[:space:]' '\n')"

# Configure common settings for all keyboard the same.
while read -r keeb; do
  if [ -n "$NX_DEBUG_RIVER" ]; then
    printf '%s\n' "Configuring keyboard \"$keeb\"…"
  fi
done <<EOF
$keebs
EOF

#
# Pointing devices
#

# Device IDs from `riverctl list-inputs`.
pointer_lgtch="pointer-1133-16505-Logitech_G_Pro"
pointer_apple="pointer-76-613-Apple_Inc._Magic_Trackpad_2"

# Concatenate and separate by newline.
pointers="$pointer_lgtch $pointer_apple"
pointers="$(printf '%s' "$pointers" | tr '[:space:]' '\n')"

# Configure common settings for all mice and trackpads the same.
while read -r pointer; do
  if [ -n "$NX_DEBUG_RIVER" ]; then
    printf "Configuring pointer device \"%s\"…\n" "$pointer"
  fi
done <<EOF
$pointers
EOF

# Disable mouse acceleration globally using profile "none" and "0" factor (min -1.0, max 1.0).
riverctl input "$pointer_lgtch" accel-profile flat
riverctl input "$pointer_lgtch" pointer-accel 0.65

# Enable acceleration (none, flat, or adaptive).
riverctl input "$pointer_apple" accel-profile adaptive

# Acceleration factor (between -1.0 and 1.0).
riverctl input "$pointer_apple" pointer-accel -0.1

# Tap to click, or click to click, it's pro-choice.
riverctl input "$pointer_apple" tap enabled

# Tap anywhere: two and three fingers for right and middle click (none, button-area, clickfinger).
riverctl input "$pointer_apple" click-method clickfinger

# Keep pointer visible when typing (Kitty terminal still hides it according to its own config).
riverctl input "$pointer_apple" disable-while-typing enabled

# Scroll with two fingers, not at edge of trackpad (none, two-finger, edge, button).
riverctl input "$pointer_apple" scroll-method two-finger

# Middle-click emulation when tapping with three fingers.
riverctl input "$pointer_apple" middle-emulation enabled

# Natural scroll direction is disgusting.
riverctl input "$pointer_apple" natural-scroll disabled

##
# KEY MAPS
##

#
# Modes
#

riverctl declare-mode passthrough
riverctl declare-mode system
riverctl declare-mode window
riverctl declare-mode window-location
riverctl declare-mode window-move
riverctl declare-mode window-resize

#
# Map keys to return to normal mode
#

nx_rctl_add_mode_exit_maps system
nx_rctl_add_mode_exit_maps window
nx_rctl_add_mode_exit_maps window-location
nx_rctl_add_mode_exit_maps window-move
nx_rctl_add_mode_exit_maps window-resize

#
# Window mode
#

# Window mode.
riverctl map normal Super W enter-mode window

# Window mode -> S => Toggle sticky tag for focused view.
riverctl map window None S toggle-view-tags "$NX_RIVER_TAGS_STICKY"

# Window mode -> P => Send focused window to scratchpad (toggle visibility with Super+Z).
riverctl map window None P set-view-tags "$NX_RIVER_TAGS_SCRATCHPAD"

# Window mode -> [1-9] => Send window to tag.
for i in $(seq 1 9); do
  tags=$((1 << (i - 1)))

  # Window mode+[1-9] to tag focused view with tag [0-8]
  riverctl map window None "$i" spawn "riverctl set-focused-tags $((NX_RIVER_TAGS_STICKY + tags)) ; eww update activetag=$i ; riverctl enter-mode normal"
done

#
# Window -> Resize mode
#

# Trigger
riverctl map window None R enter-mode window-resize

# Resize
riverctl map -repeat window-resize None H resize horizontal -50
riverctl map -repeat window-resize None J resize vertical 50
riverctl map -repeat window-resize None K resize vertical -50
riverctl map -repeat window-resize None L resize horizontal 50

#
# Window -> Move mode
#
#

# Trigger
riverctl map window None M enter-mode window-move

# Nive
riverctl map -repeat window-move None H move left 50
riverctl map -repeat window-move None J move down 50
riverctl map -repeat window-move None K move up 50
riverctl map -repeat window-move None L move right 50

#
# Window -> Main location mode
#

# Trigger
riverctl map window None L enter-mode window-location

# Move location
riverctl map window-location None H send-layout-cmd rivertile "main-location left"
riverctl map window-location None J send-layout-cmd rivertile "main-location bottom"
riverctl map window-location None K send-layout-cmd rivertile "main-location top"
riverctl map window-location None L send-layout-cmd rivertile "main-location right"

#
# System status mode
#

# Trigger
riverctl map normal Super Space enter-mode system

# Display time
riverctl map system None T spawn \
  "notify-send \"\$(date +'%H:%M')\" ; riverctl enter-mode normal"

# Display date
riverctl map system None D spawn \
  "notify-send \"\$(date +'%A · %F · Week %V')\" ; riverctl enter-mode normal"

#
# Passthrough mode for testing
#

# Trigger
riverctl map normal Super F11 enter-mode passthrough

# Exit mode
riverctl map passthrough Super F11 enter-mode normal

#
# Locked and normal mode
#

for mode in normal locked; do
  # Control volume with `pamixer`.
  riverctl map -repeat "$mode" None XF86AudioRaiseVolume spawn "pamixer -i 5"
  riverctl map -repeat "$mode" None XF86AudioLowerVolume spawn "pamixer -d 5"
  riverctl map "$mode" None XF86AudioMute spawn "pamixer --toggle-mute"

  # Control MPRIS aware media players with `playerctl`.
  riverctl map "$mode" None XF86AudioMedia spawn "playerctl play-pause"
  riverctl map "$mode" None XF86AudioPlay spawn "playerctl play-pause"
  riverctl map "$mode" None XF86AudioPrev spawn "playerctl previous"
  riverctl map "$mode" None XF86AudioNext spawn "playerctl next"

  # Control screen backlight brightness with `light`.
  riverctl map -repeat "$mode" None XF86MonBrightnessUp spawn "light -A 5"
  riverctl map -repeat "$mode" None XF86MonBrightnessDown spawn "light -U 5"
done

#
# Launchers
#
# We use our own little shell script launchers instead of some rock-solid, mature crap... In
# seriousness: we do and they're a little slow, but we cache the results so they're instant.
# Anywhere we can use `fzf` and our currently favorite terminal, we will---priceless duo.
#

# Applications and commands
riverctl map normal Super D spawn "$cmd_launch_gui"
riverctl map normal Super+Shift D spawn "$cmd_launch_cmd"
riverctl map normal Super+Control D spawn "$cmd_launch_app"

# Terminal emulators
riverctl map normal Super Return spawn "$cmd_terminal_plain"
riverctl map normal Super+Shift Return spawn "$cmd_terminal_scratchpad"
riverctl map normal Super+Control Return spawn "$cmd_terminal_popup"

# File managers
riverctl map normal Super G spawn "$cmd_files_tui"
riverctl map normal Super+Shift G spawn "$cmd_files_qt"
riverctl map normal Super+Control G spawn "$cmd_files_gtkone"
riverctl map normal Super+Alt G spawn "$cmd_files_gtktwo"

#
# System
#

# Super+Q to close view
# Super+Backspace to exit session.
riverctl map normal Super Q close
riverctl map normal Super Backspace exit

# Show status bar (starts daemon if not running).
riverctl map normal Super B spawn "eww open --toggle top-bar"

#
# Focus
#

# Super+Tab to quick switch to previous tags.
riverctl map normal Super Tab focus-previous-tags

# Super+J and Super+K to focus the next/previous view in the layout stack
# Super+Shift+J and Super+Shift+K to swap focused view with the next/previous view in stack.
riverctl map normal Super J focus-view next
riverctl map normal Super K focus-view previous
riverctl map normal Super+Shift J swap next
riverctl map normal Super+Shift K swap previous

# Output maps reversed/swapped compared to the original configuration to match the physical setup.
# Comma moves window or focus clockwise, while period moves counter-clockwise.
#
# Super+Period|Comma to focus previous/next output.
# Super+Shift+Period|Comma to send view to previous/next output.
riverctl map normal Super Comma focus-output next
riverctl map normal Super Period focus-output previous
riverctl map normal Super+Shift Comma send-to-output next
riverctl map normal Super+Shift Period send-to-output previous

#
# Layout
#

# Decrease/increase the main area ratio
riverctl map normal Super H send-layout-cmd rivertile "main-ratio -0.025"
riverctl map normal Super L send-layout-cmd rivertile "main-ratio +0.025"

# Increment/decrement the main area count
riverctl map normal Super A send-layout-cmd rivertile "main-count +1"
riverctl map normal Super X send-layout-cmd rivertile "main-count -1"

##
# POINTER MAPS
##

# TODO: If any of these buttons don't get used, change it. Have it run a custom, mouse-oriented Eww
# launcher. Toggle the scratchpad. Show the regular `fzf` lanuchers. Show pickers for clipboard
# history, passwords (with Bitwarden CLI), snippets (any code, phrase, word, or sentence sub-optimal
# to type on 60% keebs), emojis, Unicode symbols, Nerd Font icons, colors from the screen or from a
# picker like GTK's, characters like em-dashes and middle dots (similar to Kitty's picker).
# Anything. Prime button location. :)

# Normal mode without modifier.
riverctl map-pointer normal None BTN_FORWARD close
riverctl map-pointer normal None BTN_BACK enter-mode window

# Normal mode with modifier.
riverctl map-pointer normal Super BTN_LEFT move-view
riverctl map-pointer normal Super BTN_RIGHT resize-view
riverctl map-pointer normal Super BTN_MIDDLE toggle-float
riverctl map-pointer normal Super BTN_FORWARD toggle-fullscreen
riverctl map-pointer normal Super BTN_BACK enter-mode window

# Window mode without modifier.
riverctl map-pointer window None BTN_LEFT move-view
riverctl map-pointer window None BTN_RIGHT resize-view
riverctl map-pointer window None BTN_MIDDLE enter-mode normal
riverctl map-pointer window None BTN_FORWARD toggle-fullscreen
riverctl map-pointer window None BTN_BACK enter-mode normal

# Bind number keys to tag actions.
for i in $(seq 1 9); do
  tags=$((1 << (i - 1))) # Super+[1-9] to focus tag [0-8]
  riverctl map normal Super "$i" spawn "sh -c 'riverctl set-focused-tags $((NX_RIVER_TAGS_SCRATCHPAD + tags)) && eww update active-tag=$tags'"

  # Super+Shift+[1-9] to tag focused view with tag [0-8]
  riverctl map normal Super+Shift "$i" set-view-tags $tags

  # Super+Ctrl+[1-9] to toggle focus of tag [0-8]
  riverctl map normal Super+Control "$i" toggle-focused-tags $tags

  # Super+Shift+Ctrl+[1-9] to toggle tag [0-8] of focused view
  riverctl map normal Super+Alt "$i" toggle-view-tags $tags
done

# Super+0 to focus all tags.
riverctl map normal Super 0 spawn "riverctl set-focused-tags $NX_RIVER_TAGS_ALL && eww update active-tag=0"

# Toggle view-related state such as fullscreen mode, floating mode, and whether or not to insert new
# views at the top or the bottom of the list of views called the view stack.
#
# In practice, when using Rivertile, *top* means new views are moved to the main layout area on
# creation, which by default is the left half of the screen and holds a single view.
#
# The `zoom` command moves the focused view to the top of the view stack, but the focused view
# retains its focus (i.e., you have to click the view or use `Super+J` or `Super+K` focus it. and
# `Super+A` and `Super+X` increases and decreases how many views it holds).
#
# The `zoom` action that can be mapped to move a view to that area (though will not affect focus).
riverctl map normal Super F toggle-fullscreen
riverctl map normal Super+Shift F toggle-float
riverctl map normal Super+Control F zoom

##
# SCRATCHPAD AND STICKY
##

# Toggle scratchpad.
riverctl map normal Super Z toggle-focused-tags "$NX_RIVER_TAGS_SCRATCHPAD"

# Send window to scratchpad.
riverctl map normal Super+Shift Z spawn "riverctl set-view-tags "$NX_RIVER_TAGS_SCRATCHPAD && riverctl toggle-focused-tags "$NX_RIVER_TAGS_SCRATCHPAD"

# Toggle sticky.
riverctl map normal Super+Shift S toggle-view-tags "$NX_RIVER_TAGS_SCRATCHPAD"

# Ensure new windows don't have the scratchpad or sticky tag unless explicitly set.
riverctl spawn-tagmask "$NX_RIVER_TAGS_NONSPECIAL"

##
# FLOATING FILTERS
#
# We all float down here...
##

#
# Float windows by application ID (i.e., window class, or `WM_CLASS`).
#

riverctl float-filter-add app-id "MyMonero"
riverctl float-filter-add app-id "element-desktop"
riverctl float-filter-add app-id "float"
riverctl float-filter-add app-id "io.github.celluloid_player.Celluloid"
riverctl float-filter-add app-id "mpv"
riverctl float-filter-add app-id "nemo"
riverctl float-filter-add app-id "org.gnome.Nautilus"
riverctl float-filter-add app-id "org.kde.kate"
riverctl float-filter-add app-id "org.kde.kwrite"
riverctl float-filter-add app-id "org.kde.dolphin"
riverctl float-filter-add app-id "org.ksnip.ksnip"
riverctl float-filter-add app-id "org.kde.haruna"
riverctl float-filter-add app-id "pavucontrol"
riverctl float-filter-add app-id "pavucontrol-qt"
riverctl float-filter-add app-id "qt5ct"
riverctl float-filter-add app-id "qv4l2"
riverctl float-filter-add app-id "qvidcap"
riverctl float-filter-add app-id "vimiv"
riverctl float-filter-add app-id "vlc"
riverctl float-filter-add app-id "wdisplays"

#
# Terminal emulators
#

riverctl float-filter-add app-id "fuzzyterm"
riverctl float-filter-add app-id "plainterm"
riverctl float-filter-add app-id "popupterm"
riverctl float-filter-add app-id "scratchterm"
riverctl float-filter-add app-id "transterm"

#
# Float windows based on title. E.g., in Firefox Nightly it's
# "Cool site - Cool title tag - Firefox Nightly". However, this can be
# changed using browser extensions, command line flags, etc.
#

riverctl float-filter-add title "Save As",
riverctl float-filter-add title "Bitwarden"
riverctl float-filter-add title "Kvantum Manager"

# Firefox

riverctl float-filter-add title "Extension: (Clippings) - Paste Clipping — Firefox Nightly" # Snippets add-on.
riverctl float-filter-add title "Parent process Browser Toolbox"                            # Devtools for the browser itself.
riverctl float-filter-add title "Picture-in-Picture"                                        # Firefox's PIP windows.
riverctl float-filter-add title ""                                                          # Notifications. app-id is "firefox-nightly" and title is empty.

# TODO: When regular expressions are invented, use `title "Developer Tools - .+"` for Firefox.

##
# CLIENT-SIDE DECORATION FILTERS
#
# These windows will be decorated client-side instead of by River. Useful for, for example, Firefox
# or Nautilus which may have rounded corners depending on GTK theme.
##

riverctl csd-filter-add app-id "com.github.wwmm.easyeffects"
riverctl csd-filter-add app-id "firefox-nightly"
riverctl csd-filter-add app-id "nemo"
riverctl csd-filter-add app-id "org.gnome.Nautilus"
riverctl csd-filter-add app-id "org.ksnip.ksnip"
riverctl csd-filter-add app-id "io.github.celluloid_player.Celluloid"
riverctl csd-filter-add app-id "wdisplays"
riverctl csd-filter-add app-id "nemo"

##
# WRAP UP
##

#
# AUTO-START
#

riverctl spawn "pkill swaybg ; swaybg --image ~/Pictures/wallpapers/active --mode fill --output '*'"
riverctl spawn "eww --restart open top-bar"

#
# LAYOUT GENERATOR
#

riverctl default-layout rivertile

riverctl spawn "pkill rivertile ; rivertile -view-padding ${NX_RTILE_VIEW_PADDING:-10} -outer-padding ${NX_RTILE_OUTER_PADDING:-10} -main-ratio ${NX_RTILE_MAIN_RATIO:-0.5} -main-count ${NX_RTILE_MAIN_COUNT:-1} -main-location ${NX_RTILE_MAIN_LOCATION:-'left'} >/dev/null 2>$NX_RTILE_LOGFILE"

dbus-update-activation-environment --all
systemctl --user import-environment
systemctl --user start river-session.target
