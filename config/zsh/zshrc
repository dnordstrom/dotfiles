#
# ZSH CONFIGURATION
#
# Manual: https://zsh.sourceforge.io/Doc
#

#
# ZSH OPTIONS
#

# Use vi mode (recommended instead of `setopt vi`)
bindkey -v

# Show duplicates in history but ignore duplicates and space prefixed commands in reverse search
setopt nohistignoredups
setopt histfindnodups
setopt histignorespace

# Autocorrect command and arguments
setopt correct
setopt nocorrectall

# Case-insensitive autocomplete
setopt nocaseglob

# Expand aliases
setopt aliases

# Allow comments
setopt interactivecomments

# Resolve symlinks to real paths when changing directory
setopt chaselinks

#
# OPTION VARIABLES
#

#
# Zsh
#

export KEYTIMEOUT=1

#
# Shell
#

export EDITOR="nvim"
export BROWSER="firefox"
export TERMINAL="kitty"
export PAGER="less"

#
# ANSI color code helpers
#

export ANSI_STYLE_MD="$(
  tput bold
  tput setaf 6
)"
export ANSI_STYLE_ME="$(tput sgr0)"
export ANSI_STYLE_SO="$(
  tput bold
  tput setaf 0
  tput setab 3
)"
export ANSI_STYLE_SE="$(
  tput rmso
  tput sgr0
)"
export ANSI_STYLE_US="$(
  tput smul
  tput bold
  tput setaf 7
)"
export ANSI_STYLE_UE="$(
  tput rmul
  tput sgr0
)"
export ANSI_STYLE_MR="$(tput rev)"
export ANSI_STYLE_MH="$(tput dim)"

#
# Less
#

lessline=$ANSI_STYLE_SO"\ ?f\ %f:藍\ STDIN"$ANSI_STYLE_SE

export LESS="-iR -Pm$lessline\$ -Ps$lessline\$"
export LESSEDIT="%E ?lm+%lm. %g"

#
# Notes
#

export NOTES_FILE="$HOME/.notes.md"
export NOTES_EDITOR="$EDITOR"
export NOTES_VIEWER="glow -p"
export NOTES_SYMBOL="*"

#
# Fzf
#

export FZF_DEFAULT_COMMAND='rg --files --hidden --glob "!.git/*" --glob "!node_modules/*"'
export FZF_DEFAULT_OPTS="--ansi --color='bg+:-1' --cycle --no-info --prompt '› ' --pointer '➔ ' --marker '» ' --bind 'alt-p:toggle-preview,tab:down,btab:up,ctrl-y:execute-silent(wl-copy {}),ctrl-o:execute-silent(xdg-open {}),ctrl-u:half-page-up,ctrl-d:half-page-down' --preview-window ':hidden' --preview '([[ -f {} ]] && (bat --style=changes --color=always {} || cat {})) || ([[ -d {} ]] && (tree -C {} | less)) || echo {} 2> /dev/null | head -200'"
export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
export FZF_CTRL_T_OPTS="$FZF_DEFAULT_OPTS"
export FZF_ALT_C_OPTS="$FZF_DEFAULT_OPTS"
export FZF_CTRL_R_OPTS="$FZF_DEFAULT_OPTS"
export FZF_COMPLETION_OPTS="$FZF_DEFAULT_OPTS"

# Use `rg` for path completion with `fzf`.
_fzf_compgen_path() {
  rg --files --hidden --glob "!.git/*" --glob "!node_modules/*"
}

# Use `fd` for directory completion with `fzf`.
_fzf_compgen_dir() {
  fd --type d --hidden --follow --exclude ".git" . "$1"
}

# Use `fzf` with command-specific previews.
_fzf_comprun() {
  command=$1
  shift

  case "$command" in
  cd) fzf "$@" --preview 'tree -C {} | head -200' ;;
  export | unset | env) fzf "$@" --preview "eval 'echo \$'{}" ;;
  ssh) fzf "$@" --preview 'dig {}' ;;
  *) fzf "$@" ;;
  esac
}

#
# ALIASES
#

# Programs
alias e="nvim"
alias v="nvim"

# Utilities
alias icat="kitty +kitten icat"
alias themes="kitty +kitten themes"

# `cat` with line numbers and syntax highlighting
alias cat="bat"

# Default Markdown viewer
alias md="glow"
alias mdless="glow -p"

# Default list command
alias l="lt"

# Default `ls`
alias ls="printf '\n'; ls -l --almost-all --hyperlink=auto --color=auto"

# Default `lsd`
alias lsd="printf '\n'; command lsd --date=\"+%_d %b %R\" --long --hyperlink=auto --permission=octal --header --config-file=\"/home/dnordstrom/.config/lsd/config.yaml\""

# Default `exa`
alias exa="printf '\n'; command exa --all --icons --group-directories-first --group --header --git --long --no-permissions --octal-permissions"

# List with links
alias ll="printf '\n'; lsd"

# List by last modified
alias lm="printf '\n'; exa --sort=modified"
alias lmd="printf '\n'; lsd --sort=time"

# List by last accessed
alias la="printf '\n'; exa --accessed --sort=accessed"

# List as tree
alias lt="printf '\n'; list-tree-exa"
alias ltd="printf '\n'; list-tree-lsd"

# Navigate
alias cdn="cd /etc/nixos"

# NixOS
alias nixos-update="nix flake lock --update-input nixpkgs --update-input nixpkgs-master --update-input nixpkgs-wayland --update-input firefox-nightly --update-input neovim-nightly-overlay --update-input home-manager --update-input utils --update-input agenix"
alias nixos-build="doas nixos-rebuild switch --flake /etc/nixos"
alias nixos-build-impure="nixos-build --impure"
alias nixos-build-debug="nixos-build --stack-trace"
alias nixos-build-debug-impure="nixos-build-debug --impure"
alias nixos-edit="nixos-with $EDITOR"

alias ne="nixos-edit"
alias nb="nixos-build"
alias nbi="nixos-build-impure"

# Development shells
alias nix-shell-node12="nix-shell /etc/nixos/shell/node12.nix"
alias nix-shell-hugo="nix-shell /etc/nixos/shell/hugo.nix"

# Development helpers
alias g="git"
alias gc="git commit -am"
alias gf="git fetch && git pull"
alias gp="git push"
alias gs="git switch"
alias gm="git merge"

alias commit="git commit -am"
alias pull="git fetch && git pull"
alias push="git push"
alias switch="git switch"
alias merge="git merge"
alias clone="git clone"

#
# FUNCTIONS
#

py-serve() {
  python3 -m http.server "${1:-8000}" --bind 127.0.0.1
}

# Does a Git commit and push with given commit message. Fails if no message is provided.
#
# Arguments:
#   $1 - Commit message
gg() {
  if ! [ $# -eq 0 ]; then
    git commit -am "$*"
    git push
  else
    printf "\n%s\n" "Please provide a commit message."
  fi
}

# Displays a directory tree. Two optional arguments specify depth and path. If the first argument is
# a valid directory and not a number then it is displayed with a depth of 1, and otherwise the first
# argument specifies the depth and the second the directory.
#
# Arguments:
#   $1 - Depth of tree view. Optional. Defaults to 1
#   $2 - Directory to view. Optional. Defaults to working directory
list-tree-exa() {
  local levels="1"
  local paths="."

  if [ $# -gt 0 ] && ! [ -d "$1" ] && [ "$1" -eq "$1" ] 2>/dev/null; then
    levels="$1"
    shift
  fi

  if [ $# -gt 0 ]; then
    paths="$@"
  fi

  printf "\n"
  command exa -a --icons --group-directories-first --group --header --git --long --no-permissions --octal-permissions --tree --level="$levels" "$paths"
}

# Displays a directory tree. Two optional arguments specify depth and path. If the first argument is
# a valid directory and not a number then it is displayed with a depth of 1, and otherwise the first
# argument specifies the depth and the second the directory.
#
# Arguments:
#   $1 - Depth of tree view. Optional. Defaults to 1.
#   $2 - Directory to view. Optional. Defaults to working directory.
list-tree-lsd() {
  levels="1"
  paths="."

  if [ $# -gt 0 ] && ! [ -d "$1" ] && [ "$1" -eq "$1" ] 2>/dev/null; then
    levels="$1"
    shift
  fi

  if [ $# -gt 0 ]; then
    paths="$@"
  fi

  printf "\n"
  command lsd --all --date="+%_d %b %R" --permission=octal --header --long --tree --hyperlink=auto --config-file="/home/dnordstrom/.config/lsd/config.yaml" --depth="$levels" "$paths"
}

insert-date() {
  LBUFFER="$LBUFFER$(date +'%Y%m%d')"
}

prepend-date() {
  LBUFFER="$(date +'%Y%m%d')-$LBUFFER"
}

insert-timestamp() {
  LBUFFER="$LBUFFER$(date +'%Y%m%d%H%M')"
}

prepend-timestamp() {
  LBUFFER="$(date +'%Y%m%d%H%M')-$LBUFFER"
}

set-keyboard-layout() {
  swaymsg "input type:keyboard xkb_layout '${@:-"us,se"}'"
}

set-keyboard-variant() {
  swaymsg "input type:keyboard xkb_variant '${@:-","}'"
}

# Opens the notes file for viewing.
#
# Globals:
#   NOTES_FILE
#   NOTES_VIEWER
view-notes() {
  eval "${NOTES_VIEWER:-cat} $NOTES_FILE"
}

# Opens the notes file for editing.
#
# Globals:
#   EDITOR
#   NOTES_FILE
#   NOTES_EDITOR
edit-notes() {
  eval "${NOTES_EDITOR:-$EDITOR} $NOTES_FILE"
}

# Prepends argument as a list item in the notes file, defaulting to current Zsh buffer/line. This
# means we can use it both as a command (e.g. `add-note Pet cat.`) and as a widget called via key
# bind. At the time of writing, Alt+n>a (`<M-n>a` in Vimspeak). Because "Note -> Add."
#
# Arguments:
#   $1 - Note text
#
# Globals:
#   NOTES_FILE
add-note() {
  local note="${@:-$BUFFER}"

  if ! [ -z "$note" ]; then
    backup-notes
    printf "$NOTES_SYMBOL $note\n$(cat "$NOTES_FILE")" >"$NOTES_FILE"
    [ $# -eq 0 ] && zle kill-whole-line >/dev/null 2>&1
  fi
}

# Create a new backup of the notes file.
#
# Globals:
#   NOTES_FILE
backup-notes() {
  cp --backup=numbered "$NOTES_FILE" "$NOTES_FILE.$(date +%Y%m%d)"
}

# Removes all note backup files except the most recent one.
#
# Globals:
#   NOTES_FILE
clear-backup-notes() {
  rm $NOTES_FILE.*.*
}

# Checks if the given argument is a valid command or shell builtin.
#
# TODO: Suppess output if not running interactively.
#
# Arguments:
#   $1 - Command
#
# Returns:
#   0 - Command found
#   1 - Command not found
is-command() {
  # Check for builtins differently depending on shell
  if [ -n "$ZSH_VERSION" ]; then
    builtin whence -p "$1" >/dev/null 2>&1
  else
    builtin type -P "$1" >/dev/null 2>&1
  fi

  if [ $? -eq 0 ]; then
    printf "%s\n" "Command $1 exists."
    return 0
  else
    printf "%s\n" "Command $1 does not exist."
    return 1
  fi

  # Allow use in both standalone and scripts, as scripts receive script name as $0
  if [ "$#" -gt 1 ]; then
    shift
    is-command "$@"
  fi
}

# Inserts arbitrary string to command history without executing it.
#
# Arguments:
#   $1 - String to append
append-to-history() {
  string=(printf "%s\n", "$@")
  fc -R "$string"
}

# Prints a message and wait single key input, for use in command substitution.
#
# Arguments:
#   $1 - Prompt message
await-any-key() {
  printf "%s" "${@:-Press any key to continue...}"
  read -ks
  printf "\n"
}

# Prints a message and wait for y or n response, for use in command substitution.
#
# Arguments:
#   $1 - Prompt message
#
# Returns:
#   0 - Yes
#   1 - No
await-confirm() {
  message="${*:-Would you like to continue?} [Y/n] "
  read -qs "key?$message"
  return $?
}

# Prints a message and wait for enter key, for use in command substitution.
#
# Arguments:
#   $1 - Prompt message
await-enter-key() {
  printf "%s" "${*:-Press ENTER to continue...}"

  # Simply `read -s` works as well, if delimiter is newline
  while read -ks key; do
    [ "$key" = $'\x0a' ] && break
  done
}

# Prints a message and wait for user input then output it, for use in command substitution.
#
# Arguments:
#   $1 - Prompt message
#
# Returns:
#   Input string
await-string-input() {
  printf "%s " "${*:->}"
  read input
  return "$input"
}

# Converts text to lowercase.
#
# Arguments:
#   Text to convert
to-lowercase() {
  printf "%s" "$(printf "%s" "$*" | tr '[:upper:]' '[:lower:]')"
}

# Converts text to uppercase.
#
# Arguments:
#   $1 - Text to convert
to-uppercase() {
  printf "%s" "$(printf "%s" "$*" | tr '[:lower:]' '[:upper:]')"
}

# Runs command in a specific directory. Takes relative or absolute path, and neither argument require
# quoting unless the directory path contains spaces. More than one command may be specified, since
# it will be executed by `eval` (take care).
#
# Usage:
#   `in-dir [directory] [command]`
# Arguments:
#   $1 - Directory
#   $2 - Command
# Returns:
#   0 - Success
#   1 - Invalid arguments
in-dir() {
  tabs -4
  printf "\n"

  description="Runs a command in a specific directory."
  standout="$(
    tput bold
    tput setaf 0
    tput setab 3
  )"
  standoutend="$(tput sgr0)"
  usage="
Usage:
	$0 <directory> <command>...

Example:
	$0 /etc/nixos vim modules/common.nix
"

  # Make sure we have both a directory and a command
  if [ $# -lt 2 ]; then
    if [ $# -eq 0 ]; then
      printf "%s\n%s" "$description" "$usage"
    else
      printf "$standout ERROR $standoutend Expected 2 or more arguments, got %s.\n%s" "$#" "$usage"
    fi
    return 1
  fi

  absoluteDirectory="$(realpath "$1" --canonicalize-missing 2>/dev/null)"
  shift
  cmd="$@"

  # Make sure the directory exists
  if ! [ -d "$absoluteDirectory" ]; then
    printf "$standout ERROR $standoutend Could not find directory: %s\n%s" \
      "$absoluteDirectory" \
      "$usage"
    return 1
  fi

  cd "$absoluteDirectory"
  eval "$cmd"
  cd "$OLDPWD"

  return 0
}

# Changes working directory to NixOS configuration and opens it in the specified program. If no
# program is passed as argument, it will default to `$EDITOR`.
#
# Arguments:
#   $1 - Optional command or program (defaults to `$EDITOR`)
# Returns:
#   0 - Success
#   1 - Invalid argument count
# Dependencies:
#   in-dir()
edit-nixos() {
  editor="$EDITOR"

  if [ $# -gt 1 ]; then
    echo "Expected 1 argument, got $#."
    return 1
  elif [ $# -eq 1 ]; then
    editor="$1"
  fi

  in-dir "/etc/nixos" "$editor"
}

# Builds and switch to NixOS configuration. If a `.nix-prebuild` file exists in the user's home
# directory and is executable, it will be executed first (without sudo/doas---if that's needed, it
# can be added in the script itself).
#
# Notes:
#   - Uses `--impure` for out of store symlinks.
build-nixos() {
  preBuildFile="$HOME/.nix-prebuild"

  if [ -x "$preBuildFile" ]; then
    printf "\n%s\n" "Found pre-build file at: $preBuildFile"
    $preBuildFile
  fi

  doas nixos-rebuild switch --flake /etc/nixos --impure
}

# Runs `fg` command if buffer line is empty, otherwise saves current line buffer to stack.
magic-ctrl-z() {
  if [ $#BUFFER -eq 0 ]; then
    BUFFER="fg"
    zle accept-line
  else
    zle push-input
    zle clear-screen
  fi
}

# Clears the screen and returns the Zsh Vi Mode plugin to the last used mode. The `clear-screen`
# widget switches to command mode each time.
clear-screen-and-ins() {
  zle clear-screen
  ZVM_MODE="$ZVM_MODE_LAST"
}

#
# WIDGETS
#

zle -N insert-date
zle -N insert-timestamp
zle -N prepend-date
zle -N prepend-timestamp
zle -N magic-ctrl-z
zle -N edit-nixos
zle -N build-nixos
zle -N view-notes
zle -N add-note
zle -N edit-notes
zle -N backup-notes
zle -N clear-backup-notes
zle -N clear-screen-and-ins

#
# KEY BINDS
#

# Fix delete key outputting tilde character
bindkey "^[[3~" delete-char

# Alt-L uses `l` instead of `ls`
bindkey -s "^[l" "l\n"

# Ctrl-Z for fg
bindkey "^Z" magic-ctrl-z

# Ctrl-N/P navigates history matching current input
bindkey "^N" history-beginning-search-forward
bindkey "^P" history-beginning-search-backward

# Paste: Alt-P then specifier
bindkey "^[pt" insert-timestamp
bindkey "^[pd" insert-date

# Prepend paste: Shift-Alt-P then specifier
bindkey "^[Pd" prepend-date
bindkey "^[Pt" prepend-timestamp

# Notes: Alt-N then specifier
bindkey "^[na" add-note
bindkey "^[ne" edit-notes
bindkey "^[nv" view-notes

# NixOS: Shift-Alt-N then specifier
bindkey "^[Nb" build-nixos
bindkey "^[Ne" edit-nixos

#
# PLUGINS
#

#
# Zsh Vi Mode
#

# ZVM by default runs this function to set up binds lazily. We'll run it manually here since ZVM has
# already loaded. Home Manager generates the .zshrc file which loads the plugins and then appends
# this file to it, meaning ZVM inits before this function exists. So it isn't actually needed, but
# let's keep it for sentimental value (and less importantly, portability and correctness).
#
# We probably don't need to use zvm_bindkey either when we don't care about the mode, unless it does
# some weird shit bindkey doesn't. Let's use it anyway---for the excitement of uncertainty.
zvm_after_lazy_keybindings() {
  # Ctrl-N and Ctrl-P for next and previous based on current buffer content
  zvm_bindkey vicmd "^N" history-beginning-search-forward
  zvm_bindkey viins "^N" history-beginning-search-forward
  zvm_bindkey vicmd "^P" history-beginning-search-backward
  zvm_bindkey viins "^P" history-beginning-search-backward

  # Ctrl-Z to suspend or unsuspend a program to/from background
  zvm_bindkey viins "^Z" magic-ctrl-z
  zvm_bindkey vicmd "^Z" magic-ctrl-z

  # Ctrl-Alt-L returns to insert mode again after clearing screen
  zvm_bindkey viins "^[^l" clear-screen-and-ins

  # Alt-N then action to manage notes
  zvm_bindkey viins "^[na" add-note
  zvm_bindkey viins "^[ne" edit-notes
  zvm_bindkey viins "^[nv" view-notes
  zvm_bindkey vicmd "^[na" add-note
  zvm_bindkey vicmd "^[ne" edit-notes
  zvm_bindkey vicmd "^[nv" view-notes
}

# zvm_after_lazy_keybindings

# ZVM by default runs this function to set configuration late; see description of
# `zvm_after_lazy_keybindings` above as for why we run it manually.
zvm_config() {
  export ZVM_VI_INSERT_ESCAPE_BINDKEY=jk
  export ZVM_LINE_INIT_MODE=$ZVM_MODE_INSERT
  export ZVM_KEYTIMEOUT=0.4
  export ZVM_KEYTIMEOUT_ESC=0.1
}

# zvm_config

#
# PATH
#

# Script paths organized and prefixed by category: `nix/nix-preview`, `launch/launch-app`, etc.
for directory in ~/.scripts/*; do
  export PATH="$PATH:$directory"
done

#
# OTHER INIT
#

# Uncomment to:
#   Init kitty terminal shell integration
#
#   if [ -n "$KITTY_INSTALLATION_DIR" ]; then
#     export KITTY_SHELL_INTEGRATION="enabled"
#     autoload -Uz -- "$KITTY_INSTALLATION_DIR"/shell-integration/zsh/kitty-integration
#     kitty-integration
#     unfunction kitty-integration
#   fi

# Init secrets, tokens, etc.
if [ -f "$HOME/.env" ]; then
  source "$HOME/.env"
fi

# Init direnv
eval "$(direnv hook zsh)"
