#
# ZSH CONFIGURATION
#
# Manual: https://zsh.sourceforge.io/Doc
#

#
# Options
#

# Use vi mode (recommened instead of `setopt vi`)
bindkey -v

# Show duplicates in history but ignore duplicates and space prefixed commands in reverse search
setopt nohistignoredups
setopt histfindnodups
setopt histignorespace

# Autocorrect command and arguments
setopt correct
setopt nocorrectall

# Expand aliases
setopt aliases

# Allow comments
setopt interactivecomments

# Resolve symlinks to real paths when changing directory
setopt chaselinks

#
# Variables
#

# zsh

export KEYTIMEOUT=1

# Shell

export EDITOR="vim"
export BROWSER="firefox"
export TERMINAL="kitty"

# Zsh vi mode plugin

# Configuration function called when sourcing plugin
zvm_config() {
  ZVM_VI_INSERT_ESCAPE_BINDKEY=jk
  ZVM_LINE_INIT_MODE=$ZVM_MODE_INSERT
  ZVM_KEYTIMEOUT=0.4
  ZVM_KEYTIMEOUT_ESC=0.1 # Lower wait time for Escape key
}

# ANSI color code helpers

export ANSI_STYLE_MD=$(tput bold; tput setaf 6)
export ANSI_STYLE_ME=$(tput sgr0)
export ANSI_STYLE_SO=$(tput bold; tput setaf 3; tput setab 4)
export ANSI_STYLE_SE=$(tput rmso; tput sgr0)
export ANSI_STYLE_US=$(tput smul; tput bold; tput setaf 7)
export ANSI_STYLE_UE=$(tput rmul; tput sgr0)
export ANSI_STYLE_MR=$(tput rev)
export ANSI_STYLE_MH=$(tput dim)
export ANSI_STYLE_STATUS=$(tput bold; tput setaf 0; tput setab 3)
export ANSI_STYLE_STATUS_END=$(tput sgr0)

# less

local statusline=$ANSI_STYLE_STATUS"\ ?f\ %f:藍\ STDIN"$ANSI_STYLE_STATUS_END

export LESS="-iR -Pm$statusline\$ -Ps$statusline\$"
export LESSEDIT="%E ?lm+%lm. %g"
export PAGER="less"

# Notes

export NOTES_FILE="$HOME/.notes.md"
export NOTES_EDITOR="$EDITOR"
export NOTES_VIEWER="glow -p"

# bat

export BAT_STYLE="changes"
export BAT_THEME="Nord"

# fzf

export FZF_DEFAULT_COMMAND='rg --files --hidden --glob "!.git/*" --glob "!node_modules/*"'
export FZF_DEFAULT_OPTS="--ansi --color='bg+:-1' --cycle --no-info --prompt '› ' --pointer '➔ ' --marker '» ' --bind 'alt-p:toggle-preview,tab:down,btab:up,ctrl-y:execute-silent(wl-copy {}),ctrl-o:execute-silent(xdg-open {}),ctrl-u:half-page-up,ctrl-d:half-page-down' --preview-window ':hidden' --preview '([[ -f {} ]] && (bat --style=changes --color=always {} || cat {})) || ([[ -d {} ]] && (tree -C {} | less)) || echo {} 2> /dev/null | head -200'"
export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
export FZF_CTRL_T_OPTS="$FZF_DEFAULT_OPTS"
export FZF_ALT_C_OPTS="$FZF_DEFAULT_OPTS"
export FZF_CTRL_R_OPTS="$FZF_DEFAULT_OPTS"

#
# Aliases
#

# Utilities
alias icat="kitty +kitten icat"

# List files
alias l="ls -lAh --hyperlink=auto"
alias lx="exa --icons --all --group-directories-first --git --long"
alias lxg="exa --long --git --sort=modified --all --icons"
alias lxt="exa --icons --all --group-directories-first --tree --level 2"
alias ld="lsd --long --group-dirs first --almost-all"
alias ldt="lsd --tree --depth 2 --group-dirs first"

# Show contents
alias cat="bat"

# Navigate
alias cdn="cd /etc/nixos"

# Edit and build NixOS
alias nix-update="nix flake lock --update-input nixpkgs --update-input nixpkgs-master --update-input nixpkgs-wayland --update-input firefox-nightly --update-input neovim-nightly-overlay --update-input home-manager --update-input utils --update-input agenix"
alias nixos-build="doas nixos-rebuild switch --flake /etc/nixos"
alias nixos-build-debug="nix-build --stack-trace"
alias nixos-build-impure="nb --impure"
alias nixos-build-debug-impure="nbd --impure"
alias nixos-edit="nix-with $EDITOR"

# Shell environments
alias n12="nix-shell /etc/nixos/shell/node12.nix"

# Development
alias g="git"
alias gc="git commit -am"
alias gf="git fetch && git pull"
alias gp="git push"
alias gs="git switch"
alias gm="git merge"

alias commit="git commit -am"
alias pull="git fetch && git pull"
alias push="git push"
alias switch="git switch"
alias merge="git merge"
alias clone="git clone"

#
# Functions
#

# Git commit and push with given commit message. Fails if no message is provided.
#
# Arguments:
#   Commit message
gg() {
  if ! [ $# -eq 0 ]; then
    git commit -am "$*"
    git push
  else
    printf "%s\n" "Please provide a commit message."
  fi
}

insert-date() {
  LBUFFER="$LBUFFER$(date +'%Y%m%d')"
}

prepend-date() {
  LBUFFER="$(date +'%Y%m%d')-$LBUFFER"
}

insert-timestamp() {
  LBUFFER="$LBUFFER$(date +'%Y%m%d%H%M')"
}

prepend-timestamp() {
  LBUFFER="$(date +'%Y%m%d%H%M')-$LBUFFER"
}

set-keyboard-layout() {
  swaymsg "input type:keyboard xkb_layout '${@:-"us,se"}'"
}

set-keyboard-variant() {
  swaymsg "input type:keyboard xkb_variant '${@:-","}'"
}

# Open the notes file for viewing.
#
# Globals:
#   NOTES_FILE
#   NOTES_VIEWER
view-notes() {
  eval "${NOTES_VIEWER:-cat} $NOTES_FILE"
}

# Open the notes file for editing.
#
# Globals:
#   EDITOR
#   NOTES_FILE
#   NOTES_EDITOR
edit-notes() {
  eval "${NOTES_EDITOR:-$EDITOR} $NOTES_FILE"
}

# Prepend a list item to the notes file.
#
# Globals:
#   NOTES_FILE
prepend-note() {
  local note="${@:-$BUFFER}"

  if ! [ -z "$note" ]; then
    backup-notes
    printf "- $note\n$(cat "$NOTES_FILE")" > "$NOTES_FILE"
    [ $# -eq 0 ] && zle kill-whole-line > /dev/null 2>&1
  fi
}

# Create a new backup of the notes file.
#
# Globals:
#   NOTES_FILE
backup-notes() {
  cp --backup=numbered "$NOTES_FILE" "$NOTES_FILE.$(date +%Y%m%d)"
}

# Removes all note backup files except the most recent.
#
# Globals:
#   NOTES_FILE
clear-backup-notes() {
  rm $NOTES_FILE.*.*
}

# Checks if the given argument is a valid command or shell builtin, outputs the result, and returns
# 1 or 2 depending on result.
#
# Arguments:
#   Command
# Returns:
#   1 if command exists, 0 otherwise
is-command() {
  # Check for builtins differently depending on shell
  if [ -n "$ZSH_VERSION" ]; then
    builtin whence -p "$1" &> /dev/null
  else
    builtin type -P "$1" &> /dev/null
  fi

  if [ $? -ne 0 ]; then
    printf "%s\n" "Command $1 exists."
    return 1
  else
    printf "%s\n" "Command $1 does not exist."
    return 0
  fi

  # Allow use in both standalone and scripts, as scripts receive script name as $0
  if [ $# -gt 1 ]; then
    shift
    is-command "$@"
  fi
}

# Inserts arbitrary string to command history without executing it.
#
# Arguments:
#   String to append
append-to-history() {
  fc -R =(printf "%s\n" "$@")
}

# Print a message and wait single key input, for use in command substitution.
#
# Arguments:
#   Prompt message
await-any-key() {
  printf "%s" "${*:-Press any key to continue...}"
  read -ks
}

# Print a message and wait for y or n response, for use in command substitution. Outputs
# true or false depending on response.
#
# Arguments:
#   Prompt message
await-confirm() {
  local prompt="${*:-Would you like to continue?} [Y/n] "
  local output="false"
  local code=1

  read -qs "key?$prompt"
  code=$?
  [ $code -eq 0 ] && output="true"

  printf "%s" "$output"
  return $code
}

# Print a message and wait for enter key, for use in command substitution.
#
# Arguments:
#   Prompt message
await-enter-key() {
  printf "%s" "${*:-Press ENTER to continue...}"

  # Simply `read -s` works as well, if delimiter is newline
  while read -ks key; do
    [ "$key" = $'\x0a' ] && break
  done
}

# Print a message and wait for user input then output it, for use in command substitution.
#
# Arguments:
#   Prompt message
await-string-input() {
  printf "%s " "${*:->}"
  read input
  printf "%s" "$input"
}

# Convert text to lowercase.
#
# Arguments:
#   Text to convert
to-lowercase() {
  printf "%s" "$(printf "%s" "$*" | tr '[:upper:]' '[:lower:]')"
}

# Convert text to uppercase.
#
# Arguments:
#   Text to convert
to-uppercase() {
  printf "%s" "$(printf "%s" "$*" | tr '[:lower:]' '[:upper:]')"
}

# Run command in specified directory then return (use with care).
#
# Arguments:
#   Directory to run command in
#   Command to run
# Returns:
#   0 on success, 1 on invalid argument count
in-dir() {
  if ! [ $# -eq 2 ]; then
    echo "Expected 2 arguments, got $#."
    echo
    echo "Usage: $0 \"~/my_dir\" \"echo someting\""
    echo
    echo "Note that both arguments are quoted."
    return 1
  fi

  local prev_dir=$(pwd)
  local dir="$(realpath $1)"; shift
  local cmd="$*"

  cd "$dir"
  eval "$cmd"
  cd "$prev_dir"
}

# Open /etc/nixos directory with specified program.
#
# Arguments:
#   Command or program to open directory with
# Returns:
#   0 on success, 1 on invalid argument count
# Dependencies:
#   in-dir()
nix-with() {
  if ! [ $# -eq 1 ]; then
    echo "Expected 1 argument, got $#."
    return 1
  fi

  in-dir "/etc/nixos" "$1"
}

# Open NixOS configuration in Neovim
edit-nixos() {
  in-dir "/etc/nixos" "nvim"
}

# Build and switch NixOS configuration
build-nixos() {
  $HOME/.nix-prebuild
  doas nixos-rebuild switch --flake /etc/nixos --impure
}

# Run fg command if buffer line is empty, otherwise save input to stack
magic-ctrl-z() {
  if [ $#BUFFER -eq 0 ]; then
    BUFFER="fg"
    zle accept-line
  else
    zle push-input
    zle clear-screen
  fi
}

auto-correct() {
  zle spell-word
  zle self-insert
}

#
# Widgets
#

zle -N insert-date
zle -N insert-timestamp
zle -N prepend-date
zle -N prepend-timestamp
zle -N magic-ctrl-z
zle -N edit-nixos
zle -N build-nixos
zle -N view-notes
zle -N prepend-note
zle -N edit-notes
zle -N backup-notes
zle -N clear-backup-notes
zle -N auto-correct

#
# Binds
#

# Zsh vi mode binds
zvm_after_lazy_keybindings() {
  # Ctrl-N and Ctrl-P for next and previous based on current buffer content
  zvm_bindkey vicmd "^N" history-beginning-search-forward
  zvm_bindkey vicmd "^P" history-beginning-search-backward
  zvm_bindkey viins "^N" history-beginning-search-forward
  zvm_bindkey viins "^P" history-beginning-search-backward
}

# Fix delete key outputting tilde character
bindkey "^[[3~" delete-char

# Alt-L uses l instead of ls
bindkey -s "^[l" "l\n"

# Space for history
bindkey " " magic-space # Until auto-correct spell-word has been fixed to keep quotation marks

# Ctrl-Z for fg
bindkey "^Z" magic-ctrl-z

# Paste: Alt-P then specifier
bindkey "^[pt" insert-timestamp
bindkey "^[pd" insert-date

# Prepend paste: Shift-Alt-P then specifier
bindkey "^[Pd" prepend-date
bindkey "^[Pt" prepend-timestamp

# Notes: Alt-N then specifier
bindkey "^[ne" edit-notes
bindkey "^[na" prepend-note
bindkey "^[nv" view-notes

# NixOS: Shift-Alt-N then specifier
bindkey "^[Nb" build-nixos
bindkey "^[Ne" edit-nixos

#
# Path
#

# Add all custom scripts to PATH
for directory in ~/.scripts/*; export PATH="$PATH:$directory"

#
# Source secrets, etc.
#

if [ -f "$HOME/.env" ]; then
  source "$HOME/.env"
fi

eval "$(direnv hook zsh)"

