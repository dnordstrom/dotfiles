##
# ZSH CONFIGURATION
#
# Manual: https://zsh.sourceforge.io/Doc
##

#
# ZSH OPTIONS
#

zmodload zsh/complist
autoload -U compinit; compinit

# Use vi mode (recommended instead of `setopt vi`; we also use Zsh-Vi-Mode plugin)
bindkey -v

setopt glob
setopt globdots
setopt autopushd
setopt cdablevars
setopt extendedglob
setopt menucomplete
setopt alwaystoend
setopt autoparamkeys
setopt autoremoveslash
setopt noautoparamslash
setopt nomarkdirs

# History
setopt extendedhistory # Adds timestamp and duration to history.
setopt histfindnodups # Don't display diplicates in history search.
setopt histignorealldups # When inserting duplicate, remove older item.
setopt histignorespace # Leading space prevents command from being saved to history.
setopt noincappendhistory # Periodic writes. Sharing history needs this disabled.
setopt noincappendhistorytime # Periodic writes with timestamp. Sharing history needs this disabled.
setopt sharehistory # Write to history file immediately so other instances can access it right away.

# Autocorrect.
setopt correct # Autocorrect commands.
setopt nocorrectall # Don't autocorrect arguments (removes quotes if enabled)

# Case-insensitive autocomplete.
setopt nocaseglob

# Expand aliases.
setopt aliases

# Enable completion when using aliases, e.g. `gs <Tab>` shows completion of branches since it's an
# alias for `git switch`. Why `completealiases` isn't `nocompletealiases` and vice versa, who kows.
setopt nocompletealiases

# Allow comments.
setopt interactivecomments

# Resolve symlinks to real paths when changing directory.
setopt chaselinks

#
# OTHER OPTIONS
#

#
# Zsh
#

export KEYTIMEOUT=1

#
# Shell
#

export EDITOR="nvim"
export BROWSER="firefox"
export TERMINAL="kitty"
export PAGER="less"

#
# ANSI color code helpers
#

#
# Less
# 
# Let's customize the bottom status line and set the command used by the "e" edit bind.
#

lessline="$(tput bold; tput setaf 0; tput setab 3)"
lessline="$lessline\ ?f\ %f:藍\ STDIN"
lessline="$lessline$(tput sgr0)"

export LESS="-iR -Pm$lessline\$ -Ps$lessline\$"
export LESSEDIT="%E ?lm+%lm. %g"

#
# Notes
#
# Options for note-taking functions and widgets defined further down. Typing "Awesome note!" and
# pressing `Alt-n` followed by `a` will run the `add-note` widget and insert a new "* Awesome note!"
# list item at the top of ~/.notes.md. Running `add-note Awesome note!` directly works too.
#

export NOTES_FILE="$HOME/.notes.md"
export NOTES_EDITOR="$EDITOR"
export NOTES_VIEWER="glow -p"
export NOTES_SYMBOL="*"

#
# Fzf
#
# Sets default options for `fzf`, for example:
#
# * Uses and sets colors.
# * Uses `bat` to preview.
# * Uses `rg` to search (faster `grep` written in Rust).
# * Uses Nerd Font glyphs for prompt, pointer, and markers.
# * Uses custom binds (e.g. Alt-p to preview, Ctrl-y to copy, and Ctrl-o to open with `xdg-open`).
#

# Catppuccin Latte theme with added boldness and disabled background to better match terminal.
# Palette variants are available in the official repository: https://github.com/catppuccin/fzf
opts="--color=bg+:-1,bg:-1,spinner:#dc8a78,hl:#d20f39"
opts="--color=fg:#4c4f69,header:#d20f39,info:#8839ef,pointer:#dc8a78 $opts"
opts="--color=marker:#dc8a78,fg+:#4c4f69,prompt:#8839ef,hl+:#d20f39 $opts"

# General

opts="--ansi $opts" # Enable ANSI color escape sequences
opts="--cycle $opts" # Enable cycling from end to beginning
opts="--no-info $opts" # Disable item count
opts="--prompt ' ' $opts" # Prompt character
opts="--pointer '➔ ' $opts" # Focused item pointer
opts="--marker '» ' $opts" # Selected item marker
opts="--preview-window hidden $opts" # Hide preview by default
opts="--ellipsis … $opts" # Use proper ellipsis instead of two(?) periods

# Binds (split for readability, `--bind 'tab:down,btab:up,...` works)

opts="--bind 'tab:down' $opts"
opts="--bind 'btab:up' $opts"

opts="--bind 'ctrl-space:toggle-down' $opts"
opts="--bind 'alt-space:toggle-up' $opts"

opts="--bind 'ctrl-y:execute-silent(wl-copy {})+abort' $opts"
opts="--bind 'ctrl-x:execute-silent(xdg-open {})+abort' $opts"

opts="--bind 'ctrl-u:page-up' $opts"
opts="--bind 'ctrl-d:page-down' $opts"

opts="--bind 'alt-p:toggle-preview' $opts"
opts="--bind 'alt-w:toggle-preview-wrap' $opts"

opts="--bind 'alt-u:preview-page-up' $opts"
opts="--bind 'alt-d:preview-page-down' $opts"

opts="--bind 'alt-h:preview-half-page-up' $opts"
opts="--bind 'alt-j:preview-down' $opts"
opts="--bind 'alt-k:preview-up' $opts"
opts="--bind 'alt-l:preview-half-page-down' $opts"

# Generic previewer showing file/directory icon (using `exa`), name, and output of:
#   Files           -> `bat` or `cat`
#   Directories     -> `exa` in tree view
#   Arbitrary text  -> `echo`
# opts="--preview='\
#   [ -f {} ] && ( \
#     (command exa --icons --tree --level=1 {} | head -1 && printf "\n") && \
#     (bat --style=plain --color=always {} || cat {})
#   ) || \
#   [ -d {} ] && ( \
#     (command exa -a --icons --group-directories-first --tree --level=2 {})
#   )\
# ' $opts"

export FZF_DEFAULT_OPTS="$opts"
export FZF_DEFAULT_COMMAND="rg --files --hidden --glob='!.git/*' --glob='!node_modules/*'"
export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
export FZF_CTRL_T_OPTS="$FZF_DEFAULT_OPTS"
export FZF_ALT_C_OPTS="$FZF_DEFAULT_OPTS"
export FZF_CTRL_R_OPTS="$FZF_DEFAULT_OPTS"
export FZF_COMPLETION_OPTS="$FZF_DEFAULT_OPTS"

# Fzf-Tab plugin
#
# This plugin is used to replace the default Zsh autocomplete with `fzf` everywhere, so we can use
# tab rather than an explicit trigger. Using this we can do `cd Docu<Tab>` rather than `cd **<Tab>`.
#
# It's configured using `zstyle` and we can set up differently for specific commands: for `cd` and
# any aliases to it we'd use the `:fzf-tab:complete:cd:*` context.
#
# Documentation: https://github.com/Aloxaf/fzf-tab/wiki/Configuration

# Generic previewer.
preview='\
  [ -f "$realpath" ] && ( \
    (command exa --icons --tree --level=1 "$realpath" | head -1 && printf "\n") && \
    (bat --style=plain --color=always "$realpath" || cat "$realpath")
  ) || \
  [ -d "$realpath" ] && ( \
    (command exa -a --icons --group-directories-first --tree --level=2 "$realpath")
  ) || \
  echo "$realpath" 2> /dev/null \
'
# Set and export `$LS_COLORS` to be used in menus/lists.
eval "$(dircolors)"

# Set format to enable display of groups to differentiate local directories vs cdpath, built-in
# commands vs installed binaries, and so on.
zstyle ':completion:*:descriptions' format '%d '
zstyle ':completion:*:git-checkout:*' sort false
zstyle ':fzf-tab:*' show-group full
zstyle ':fzf-tab:*' switch-group '>' '<' # Switch group using angle bracket keys.
zstyle ':fzf-tab:*' prefix ''

# Set list colors to enable colorization
zstyle ':completion:*' list-colors-extended true
zstyle ':completion:*:*:*:*:default' list-colors ${(s.:.)LS_COLORS}

# Generic completion.
zstyle ':completion:*' complete-options true
zstyle ':completion:*' file-sort modification
zstyle ':fzf-tab:complete:*:*' fzf-flags --preview-window 'hidden'
zstyle ':fzf-tab:complete:*:*' fzf-preview $preview
zstyle ':fzf-tab:complete:*:*' print-query alt-enter

# Showing preview window on launch.
zstyle ':fzf-tab:complete:(cd|nvim):*' fzf-flags --preview-window 'nohidden'

# `which`
zstyle ':fzf-tab:complete:which:*' fzf-flags --preview-window 'down,20%,wrap,nohidden'
zstyle ':fzf-tab:complete:which:*' fzf-preview 'command -v $word && which $word'

# `export`
zstyle ':fzf-tab:complete:export:*' fzf-flags --preview-window 'down,20%,wrap,nohidden'
zstyle ':fzf-tab:complete:export:*' fzf-bindings \
  'ctrl-y:execute-silent({_FTB_INIT_}printf "%s=\"%s\"" "$word" "$(eval echo \$$word)" | wl-copy)+abort'
zstyle ':fzf-tab:complete:export:*' fzf-preview \
  'printf "%s=\"%s\"" "$word" "$(eval echo \$$word)" | bat --language sh --style plain --color always'

#
# ALIASES
#

# Programs
alias e="nvim"

# Utilities
alias hg="kitty +kitten hyperlinked_grep"
alias icat="printf '\n\n' ; kitty +kitten icat"
alias themes="kitty +kitten themes"

# `cat` with line numbers and syntax highlighting
alias c="bat"
alias cat="bat"
alias cat-plain="command cat"

# Default Markdown viewer
alias md="mdcat"

# Default list command
alias l="lt"

# Default `ls`
alias ls="printf '\n'; ls -l --almost-all --hyperlink=auto --color=auto"

# Default `lsd`
alias lsd="printf '\n'; command lsd --date=\"+%_d %b %R\" --long --hyperlink=auto --permission=octal --header --config-file=\"/home/dnordstrom/.config/lsd/config.yaml\""

# Default `exa`
alias exa="printf '\n'; command exa --all --icons --group-directories-first --group --header --git --long --no-permissions --octal-permissions"

# List with links
alias ll="printf '\n'; lsd"

# List by last modified
alias lm="printf '\n'; exa --sort=modified"
alias lmd="printf '\n'; lsd --sort=time"

# List by last accessed
alias la="printf '\n'; exa --accessed --sort=accessed"

# List as tree
alias lt="printf '\n'; list-tree-exa"
alias ltd="printf '\n'; list-tree-lsd"

# Print `PATH` one entry per line
alias print-path='printf "\n$(tput setaf 0; tput setab 3; tput bold) PATH ENVIRONMENT VARIABLE $(tput sgr0; tput setaf 4; tput bold)\n\n%s\n$(tput sgr0)" "$PATH" | tr "[=:=]" "\n"'

# Navigate
alias cdn="cd /etc/nixos"

# NixOS
alias nixos-update="nix flake lock --update-input nixpkgs --update-input nixpkgs-master --update-input nixpkgs-wayland --update-input firefox-nightly --update-input neovim-nightly-overlay --update-input home-manager --update-input utils --update-input agenix"
alias nixos-build="doas nixos-rebuild switch --flake /etc/nixos"
alias nixos-build-impure="nixos-build --impure"
alias nixos-build-debug="nixos-build --stack-trace"
alias nixos-build-debug-impure="nixos-build-debug --impure"
alias nixos-edit="nixos-with $EDITOR"
alias nixos-print-gcroots='find -H /nix/var/nix/gcroots/auto -type l | xargs -- printf "Readlink: %s\nRealpath: %s\n\n" "$(readlink {})" "$(realpath {})"'

alias ne="nixos-edit"
alias nb="nixos-build"
alias nbi="nixos-build-impure"

# Nix shells
alias nix-shell-node12="nix-shell /etc/nixos/shell/node12.nix"
alias nix-shell-hugo="nix-shell /etc/nixos/shell/hugo.nix"

# VPNs
alias vpn-leeroy-up="openvpn3 session-start --config $HOME/Secrets/openvpn/leeroy.ovpn"
alias vpn-leeroy-down="openvpn3 session-manage --disconnect --config $HOME/Secrets/openvpn/leeroy.ovpn"
alias vpn-leeroy-status="openvpn3 session-stats --config $HOME/Secrets/openvpn/leeroy.ovpn"

alias vpn-proton-up="doas protonvpn connect --fastest"
alias vpn-proton-down="doas protonvpn disconnect"
alias vpn-proton-status="doas protonvpn status"
alias vpn-proton-up-securecore="doas protonvpn connect --sc"
alias vpn-proton-up-p2p="doas protonvpn connect --p2p"

#
# INFORMATION QUERYING
#

alias n-getsysteminfo="command cat /sys/devices/virtual/dmi/id/board_{vendor,name,version}"

#
# DEVELOPMENT
#

alias gc="git commit -am"
alias gc="git diff"
alias gf="git fetch && git pull"
alias gp="git push"
alias gs="git switch"
alias gm="git merge"
alias gi="git status"

alias commit="git commit -am"
alias pull="git fetch && git pull"
alias push="git push"
alias switch="git switch"
alias merge="git merge"
alias clone="git clone"

# Generate a `sh -c ...` command for running the given command(s), enclosed in single quotes after
# the command has done the substitution.
#
# Notes:
#   - I prefer explicit naming in combination with aliases, rather than short ambiguous naming.
#
# Example:
#     $ riverctl spawn $(shell_command "systemctl --user enable cool.service && nvim README.md")
#     = riverctl spawn zsh -c 'systemctl --user enable cool.service && nvim README.md'
#
# Options:
#   --shell,-s  Shell that should run the command, e.g. `zsh`. Defaults to `$SHELL` or `sh`.
#
# Arguments: 
#   - $* - Any arguments are passed to she shell as command to run, as printed by `printf`.
#
# Returns:
#   - In terminal context, outputs shell command to standard output.
#   - In non-terminal contexts (e.g. piped to from another command), return the shell command.
#
# Globals:
#   - SHELL is used as the shell to launch. Until threre's a flag, it can be changed there:
#     `SHELL=zsh echo "$(shell_command echo Hello, dear world.)"`
shell_cmd() {
  printUsage() {
    printf "\n%s\n" "
$(basename "$0") [OPTIONS] <command line>

DESCRIPTION:
  Print a `sh -c 'arguments here'` string for spawning processes that use e.g. pipes, in a shell of your choosing.

OPTIONS:
    -s, --shell     Shell that will run the command.
    -h, --help      Show this help text.
"
  }

  for arg in "$@"; do
    case $arg in
      -h|--help)
      print-usage
      exit 0
      shift
      ;;
      -s|--shell)
      shell="${${1:-$SHELL}:-sh}"
      shift
      ;;
      *)
      cmdstring="$1"
      shift
      ;;
    esac
  done

  if [ "$option_all" = "true" ]; then
    properties="initial"
  fi
  shell="${SHELL:-"sh"}"
  result="$(printf "%s" "$shell -c '$*'")"

  if [ -t 0 ]; then
    printf "%s" "$result"
  else
    return "$result"
  fi
}

# Get only the relevant information about current Wayland views/windows.
#
# TODO: Refactor Wayland helpers into reusable `jq` fragments, add delay option, and env variables..
#
# Arguments:
#   - $1 - Subcommand, e.g. `all` (or `--all`) to include all properties instead of a limited set.
#
# Returns:
#   JSON representation of current view tree.
wl-views() {
  printUsage() {
    printf "\n%s\n" "
$(basename "$0") [OPTIONS] [GREP STRING]

DESCRIPTION:
    Use `--all` (or `-a` or `all`) for all view properties, `--focused` for only the focused view, an optional string to grep results, or omit arguments to show `app_id`, `title`, and `activated` properties of all views.

OPTIONS:
    -a, --all       Show detailed view including all properties.
    -f, --focused   Show only properties of the focused view.
    -h, --help      Show this help text.
"
  }

  properties="relevant"
  views_cmd="lswt --json"
  parse_cmd="jq"
  grep_cmd="grep"
  query=". as \$initial | \$initial[] | {app_id, title, activated} as \$relevant"

  for arg in "$@"; do
    case $arg in
      -h|--help)
      print-usage
      exit 0
      shift
      ;;
      -a|--all|a|all)
      option_all=true
      shift
      ;;
      -f|--focused|f|focused)
      option_focused=true
      shift
      ;;
      *)
      option_grep=true
      grepstring="$1"
      shift
      ;;
    esac
  done

  if [ "$option_all" = "true" ]; then
    properties="initial"
  fi

  if [ "$option_focused" = "true" ]; then
    query="$query | select(.activated == true)"
  fi

  query="$query | \$$properties"

  if [ "$option_grep" = "true" ]; then
    if [ -n "$grepstring" ]; then
      cmd="$views_cmd | $parse_cmd '$query' | $grep_cmd $grepstring"
    else
      printf "\n%s\n\n" "Invalid argument specified." "$usage"
    fi
  else
    cmd="$views_cmd | $parse_cmd '$query'"
  fi

  eval $cmd
}

# Parse a Jira issue ID from string provided either as argument or piped to standard input. For now,
# if no input is provided then the current Git branch name is parsed.
#
# If no ID could be found, it returns `{ "error": "Not found." }`
#
# Arguments:
#   - $* - Arguments are combined to a string and parsed. (Optional.)
#
# Returns:
#   Success - E.g. `{ "project": "CLASS", "id": 123 }`.
#   Failure - E.g. `{ "error": "Not found." }`.
jira-parse-id() {
  # Use `test -t 0` to check if the standard input file descriptor (0) refers to a terminal. If it does, then we're calling the function directly with content passed as argument, and if it doesn't, then we assume content is piped to us from another command.
  if ! [ -t 0 ]; then
    cat | jq --raw-input '[capture("(?<a>[a-z]+)-(?<n>[0-9]+)"; "gi")] | [(.[] | {"project": (.a | ascii_upcase), "issue": .n | tonumber})] | if length == 0 then {"error": "Not found."} | halt_error(1) else . end'
    return
  fi
  
  # If one or more arguments are given, pipe them all as raw string to `jq`. If no argument is
  # given, check current Git branch name by default.
  if [ $# -eq 0 ]; then
    query="$(git branch --show-current)"
  else
    query="$*"
  fi

  printf "%s" "$query" | jq --raw-input --slurp '[capture("(?<a>[a-z]+)-(?<n>[0-9]+)"; "gi")] | [(.[] | {"project": (.a | ascii_upcase), "issue": .n | tonumber})] | if length == 0 then {"error": "Not found."} | halt_error(1) else . end'
}

# `g` - Runs `git status` when no arguments are used, otherwise passes them on to `git`.
#
# Arguments:
# - $* - Arguments passed to `git` when used as an alias. (Optional.)
g() {
  if [ $# -eq 0 ]; then
    git status
  else
    git $*
  fi
}

# Does a Git commit and push with given commit message. Fails if no message is provided.
#
# Arguments:
#   $1 - Commit message
gg() {
  if ! [ $# -eq 0 ]; then
    git commit -am "$*"
    git push
  else
    printf "\n%s\n" "Please provide a commit message."
  fi
}

# Starts a simple Python 3 HTTP server listening on the given port (default: 6969). Port may also be
# specified using the `PORT` environment variable, just in case we get shit mixed uo.
#
# Arguments:
#   $1 - Port the server will listen on.
py-serve() {
  port="${PORT:-6969}"
  ip="127.0.0.1"

  python3 -m http.server "${1:-$port}" --bind "$ip"
}

#
# FUNCTIONS
#

# Prints environment variables that start with given string converted in uppercase. Defaults to
# print `$PATH`.
#
# Arguments:
#   $1 - Environment variable name or start of name.
#
# Outputs:
#   Value of any environment variables that start with uppercase transformed input string.
var() {
  query="${1:-PATH}"
  titlestart="$(tput setaf 0; tput setab 3; tput bold)"
  titleend="$(tput sgr0)"
  title="ENVIRONMENT VARIABLES MATCHING /^$query.*/"

  printf "\n%s\n\n" "$titlestart $title $titleend"

  env | rg --smart-case --color=always --regexp="^$query.*"
}

# Prints a super simple eight column table with the 256 eight bit colors for reference.
#
#       0-7:  Standard colors (as in ESC [ 30–37 m)
#      8-15:  High intensity colors (as in ESC [ 90–97 m)
#    16-231:  6 × 6 × 6 cube (216 colors): 16 + 36 × r + 6 × g + b (0 ≤ r, g, b ≤ 5)
#   232-255:  Grayscale from black to white in 24 steps
print-ansi-colors() {
  printf \
    "\n$(tput bold; tput setaf 0; tput setab 3) ANSI COLORS $(tput sgr0)\n\n%s\n%s\n%s\n%s\n\n" \
    "    0-7: Standard colors (as in ESC[30–37m)" \
    "   8-15: High intensity colors (as in ESC[90–97m)" \
    " 16-231: 6×6×6 cube (216 colors): 16+36×r+6×g+b (0≤r, g, b≤5)" \
    "232-255: Grayscale from black to white in 24 steps"

  for i in {0..255}; do
    print -Pn "%K{$i}    %k%F{$i} ${(l:3::0:)i}%f " ${${(M)$((i%8)):#7}:+$'\n'}
  done
}

# Displays a directory tree. Two optional arguments specify depth and path. If the first argument is
# a valid directory and not a number then it is displayed with a depth of 1, and otherwise the first
# argument specifies the depth and the second the directory.
#
# Arguments:
#   $1 - Depth of tree view. Optional. Defaults to 1
#   $2 - Directory to view. Optional. Defaults to working directory
list-tree-exa() {
  local levels="1"
  local paths="."

  if [ $# -gt 0 ] && ! [ -d "$1" ] && [ "$1" -eq "$1" ] 2>/dev/null; then
    levels="$1"
    shift
  fi

  if [ $# -gt 0 ]; then
    paths="$@"
  fi

  printf "\n"
  command exa -a --icons --group-directories-first --group --header --git --long --no-permissions --octal-permissions --tree --level="$levels" "$paths"
}

# Displays file (or directory) name and icon grabbed from `exa`.
#
# Arguments:
#   $1 - Path of file or directory (default: working directory).
pretty-file-name() {
  command exa --icons --tree --level=1 "${*:-$PWD}" | head -1 && printf "\n"
}

# Displays file (or directory) icon only grabbed from `exa`.
#
# Arguments:
#   $1 - Path of file or directory (default: working directory).
pretty-file-icon() {
  command exa --icons --tree --level=1 "${*:-$PWD}" | head -1 | cut -c-3 && printf "\n"
}

# Displays a directory tree. Two optional arguments specify depth and path. If the first argument is
# a valid directory and not a number then it is displayed with a depth of 1, and otherwise the first
# argument specifies the depth and the second the directory.
#
# Arguments:
#   $1 - Depth of tree view. Optional. Defaults to 1.
#   $2 - Directory to view. Optional. Defaults to working directory.
list-tree-lsd() {
  levels="1"
  paths="."

  if [ $# -gt 0 ] && ! [ -d "$1" ] && [ "$1" -eq "$1" ] 2>/dev/null; then
    levels="$1"
    shift
  fi

  if [ $# -gt 0 ]; then
    paths="$@"
  fi

  printf "\n"
  command lsd --all --date="+%_d %b %R" --permission=octal --header --long --tree --hyperlink=auto --config-file="/home/dnordstrom/.config/lsd/config.yaml" --depth="$levels" "$paths"
}

insert-date() {
  LBUFFER="$LBUFFER$(date +'%Y%m%d')"
}

prepend-date() {
  LBUFFER="$(date +'%Y%m%d')-$LBUFFER"
}

insert-timestamp() {
  LBUFFER="$LBUFFER$(date +'%Y%m%d%H%M')"
}

prepend-timestamp() {
  LBUFFER="$(date +'%Y%m%d%H%M')-$LBUFFER"
}

set-keyboard-layout() {
  swaymsg "input type:keyboard xkb_layout '${@:-"us,se"}'"
}

set-keyboard-variant() {
  swaymsg "input type:keyboard xkb_variant '${@:-","}'"
}

# Opens the notes file for viewing.
#
# Globals:
#   NOTES_FILE
#   NOTES_VIEWER
view-notes() {
  eval "${NOTES_VIEWER:-cat} $NOTES_FILE"
}

# Opens the notes file for editing.
#
# Globals:
#   EDITOR
#   NOTES_FILE
#   NOTES_EDITOR
edit-notes() {
  eval "${NOTES_EDITOR:-$EDITOR} $NOTES_FILE"
}

# Prepends argument as a list item in the notes file, defaulting to current Zsh buffer/line. This
# means we can use it both as a command (e.g. `add-note Pet cat.`) and as a widget called via key
# bind. At the time of writing, Alt+n>a (`<M-n>a` in Vimspeak). Because "Note -> Add."
#
# Arguments:
#   $1 - Note text
#
# Globals:
#   NOTES_FILE
add-note() {
  local note="${@:-$BUFFER}"

  if ! [ -z "$note" ]; then
    backup-notes
    printf "$NOTES_SYMBOL $note\n$(cat "$NOTES_FILE")" >"$NOTES_FILE"
    [ $# -eq 0 ] && zle kill-whole-line >/dev/null 2>&1
  fi
}

# Create a new backup of the notes file.
#
# Globals:
#   NOTES_FILE
backup-notes() {
  cp --backup=numbered "$NOTES_FILE" "$NOTES_FILE.$(date +%Y%m%d)"
}

# Removes all note backup files except the most recent one.
#
# Globals:
#   NOTES_FILE
clear-backup-notes() {
  rm $NOTES_FILE.*.*
}

# Check if string contains another string.
#
# Arguments:
#   $1 - $haystack -  String to search.
#   $2 - $needle   -  String to search for.
stringcontains() {
  string="$1"
  substring="$2"

  if [ "${string#*$substring}" != "$string" ]; then
    return 0
  else
    return 1
  fi
}

# Checks if the given argument is a valid command or shell builtin.
#
# TODO: Suppess output if not running interactively.
#
# Arguments:
#   $1 - Command
#
# Returns:
#   0 - Command found
#   1 - Command not found
is-command() {
  # Check for builtins differently depending on shell
  if [ -n "$ZSH_VERSION" ]; then
    builtin whence -p "$1" >/dev/null 2>&1
  else
    builtin type -P "$1" >/dev/null 2>&1
  fi

  if [ $? -eq 0 ]; then
    printf "%s\n" "Command $1 exists."
    return 0
  else
    printf "%s\n" "Command $1 does not exist."
    return 1
  fi

  # Allow use in both standalone and scripts, as scripts receive script name as $0
  if [ "$#" -gt 1 ]; then
    shift
    is-command "$@"
  fi
}

# Inserts arbitrary string to command history without executing it.
#
# Arguments:
#   $1 - String to append
append-to-history() {
  string=(printf "%s\n", "$@")
  fc -R "$string"
}

# Prints a message and wait single key input, for use in command substitution.
#
# Arguments:
#   $1 - Prompt message
await-any-key() {
  printf "%s" "${@:-Press any key to continue...}"
  read -ks
  printf "\n"
}

# Prints a message and wait for y or n response, for use in command substitution.
#
# Arguments:
#   $1 - Prompt message
#
# Returns:
#   0 - Yes
#   1 - No
await-confirm() {
  message="${*:-Would you like to continue?} [Y/n] "
  read -qs "key?$message"
  return $?
}

# Prints a message and wait for enter key, for use in command substitution.
#
# Arguments:
#   $1 - Prompt message
await-enter-key() {
  printf "%s" "${*:-Press ENTER to continue...}"

  # Simply `read -s` works as well, if delimiter is newline
  while read -ks key; do
    [ "$key" = $'\x0a' ] && break
  done
}

# Prints a message and wait for user input then output it, for use in command substitution.
#
# Arguments:
#   $1 - Prompt message
#
# Returns:
#   Input string
await-string-input() {
  printf "%s " "${*:->}"
  read input
  return "$input"
}

# Converts text to lowercase.
#
# Arguments:
#   Text to convert
to-lowercase() {
  printf "%s" "$(printf "%s" "$*" | tr '[:upper:]' '[:lower:]')"
}

# Converts text to uppercase.
#
# Arguments:
#   $1 - Text to convert
to-uppercase() {
  printf "%s" "$(printf "%s" "$*" | tr '[:lower:]' '[:upper:]')"
}

# Runs command in a specific directory. Takes relative or absolute path, and neither argument require
# quoting unless the directory path contains spaces. More than one command may be specified, since
# it will be executed by `eval` (take care).
#
# Usage:
#   `in-dir [directory] [command]`
# Arguments:
#   $1 - Directory
#   $2 - Command
# Returns:
#   0 - Success
#   1 - Invalid arguments
in-dir() {
  tabs -4
  printf "\n"

  description="Runs a command in a specific directory."
  standout="$(
    tput bold
    tput setaf 0
    tput setab 3
  )"
  standoutend="$(tput sgr0)"
  usage="
Usage:
	$0 <directory> <command>...

Example:
	$0 /etc/nixos vim modules/common.nix
"

  # Make sure we have both a directory and a command
  if [ $# -lt 2 ]; then
    if [ $# -eq 0 ]; then
      printf "%s\n%s" "$description" "$usage"
    else
      printf "$standout ERROR $standoutend Expected 2 or more arguments, got %s.\n%s" "$#" "$usage"
    fi
    return 1
  fi

  absoluteDirectory="$(realpath "$1" --canonicalize-missing 2>/dev/null)"
  shift
  cmd="$@"

  # Make sure the directory exists
  if ! [ -d "$absoluteDirectory" ]; then
    printf "$standout ERROR $standoutend Could not find directory: %s\n%s" \
      "$absoluteDirectory" \
      "$usage"
    return 1
  fi

  cd "$absoluteDirectory"
  eval "$cmd"
  cd "$OLDPWD"

  return 0
}

# Changes working directory to NixOS configuration and opens it in the specified program. If no
# program is passed as argument, it will default to `$EDITOR`.
#
# Arguments:
#   $1 - Optional command or program (defaults to `$EDITOR`)
# Returns:
#   0 - Success
#   1 - Invalid argument count
# Dependencies:
#   in-dir()
edit-nixos() {
  editor="$EDITOR"

  if [ $# -gt 1 ]; then
    echo "Expected 1 argument, got $#."
    return 1
  elif [ $# -eq 1 ]; then
    editor="$1"
  fi

  in-dir "/etc/nixos" "$editor"
}

# Builds and switch to NixOS configuration. If a `.nix-prebuild` file exists in the user's home
# directory and is executable, it will be executed first (without sudo/doas---if that's needed, it
# can be added in the script itself).
#
# Notes:
#   - Uses `--impure` for out of store symlinks.
build-nixos() {
  preBuildFile="$HOME/.nix-prebuild"

  if [ -x "$preBuildFile" ]; then
    printf "\n%s\n" "Found pre-build file at: $preBuildFile"
    $preBuildFile
  fi

  doas nixos-rebuild switch --flake /etc/nixos --impure
}

# Runs `fg` command if buffer line is empty, otherwise saves current line buffer to stack.
magic-ctrl-z() {
  if [ $#BUFFER -eq 0 ]; then
    BUFFER="fg"
    zle accept-line
  else
    zle push-input
    zle clear-screen
  fi
}

# Clears the screen and returns the Zsh Vi Mode plugin to the last used mode. The `clear-screen`
# widget switches to command mode each time.
clear-screen-and-ins() {
  zle clear-screen
  ZVM_MODE="$ZVM_MODE_LAST"
}

#
# WIDGETS
#

zle -N insert-date
zle -N insert-timestamp
zle -N prepend-date
zle -N prepend-timestamp
zle -N magic-ctrl-z
zle -N edit-nixos
zle -N build-nixos
zle -N view-notes
zle -N add-note
zle -N edit-notes
zle -N backup-notes
zle -N clear-backup-notes
zle -N clear-screen-and-ins
zle -N fzf_comprun _fzf_comprun

#
# KEY BINDS
#

# Fix delete key outputting tilde character
bindkey "^[[3~" delete-char

# Alt-L uses `l` instead of `ls`
bindkey -s "^[l" "l\n"

# Ctrl-Z for fg
bindkey "^Z" magic-ctrl-z

# Ctrl-N/P navigates history matching current input
bindkey "^N" history-beginning-search-forward
bindkey "^P" history-beginning-search-backward

# Paste: Alt-P then specifier
bindkey "^[pt" insert-timestamp
bindkey "^[pd" insert-date

# Prepend paste: Shift-Alt-P then specifier
bindkey "^[Pd" prepend-date
bindkey "^[Pt" prepend-timestamp

# Notes: Alt-N then specifier
bindkey "^[na" add-note
bindkey "^[ne" edit-notes
bindkey "^[nv" view-notes

# NixOS: Shift-Alt-N then specifier
bindkey "^[Nb" build-nixos
bindkey "^[Ne" edit-nixos

#
# PLUGINS
#

#
# Zsh Vi Mode
#

# ZVM by default runs this function to set up binds lazily. We'll run it manually here since ZVM has
# already loaded. Home Manager generates the .zshrc file which loads the plugins and then appends
# this file to it, meaning ZVM inits before this function exists. So it isn't actually needed, but
# let's keep it for sentimental value (and less importantly, portability and correctness).
#
# We probably don't need to use zvm_bindkey either when we don't care about the mode, unless it does
# some weird shit bindkey doesn't. Let's use it anyway---for the excitement of uncertainty.
zvm_after_lazy_keybindings() {
  # Ctrl-N and Ctrl-P for next and previous based on current buffer content
  zvm_bindkey vicmd "^N" history-beginning-search-forward
  zvm_bindkey viins "^N" history-beginning-search-forward
  zvm_bindkey vicmd "^P" history-beginning-search-backward
  zvm_bindkey viins "^P" history-beginning-search-backward

  # Ctrl-Z to suspend or unsuspend a program to/from background
  zvm_bindkey viins "^Z" magic-ctrl-z
  zvm_bindkey vicmd "^Z" magic-ctrl-z

  # Ctrl-Alt-L returns to insert mode again after clearing screen
  zvm_bindkey viins "^[^l" clear-screen-and-ins

  # Alt-N then action to manage notes
  zvm_bindkey viins "^[na" add-note
  zvm_bindkey viins "^[ne" edit-notes
  zvm_bindkey viins "^[nv" view-notes
  zvm_bindkey vicmd "^[na" add-note
  zvm_bindkey vicmd "^[ne" edit-notes
  zvm_bindkey vicmd "^[nv" view-notes
}

# ZVM by default runs this function to set configuration late; see description of
# `zvm_after_lazy_keybindings` above as for why we run it manually.
zvm_config() {
  export ZVM_VI_INSERT_ESCAPE_BINDKEY=jk
  export ZVM_LINE_INIT_MODE=$ZVM_MODE_INSERT
  export ZVM_KEYTIMEOUT=0.4
  export ZVM_KEYTIMEOUT_ESC=0.1
}

# zvm_config

#
# PATH
#

# Script paths organized and prefixed by category: `nix/nix-preview`, `launch/launch-app`, etc.
for directory in ~/.scripts/**; do
  export PATH="$PATH:$directory"
done

#
# OTHER INIT
#

# Kitty terminal automatically loads shell integration when spawning a shell directly. However, it
# won't load automatically if running e.g. `tmux`, or `exec zsh` to source new settings.
if [ -n "$KITTY_INSTALLATION_DIR" ]; then
  export KITTY_SHELL_INTEGRATION="enabled"
  autoload -Uz -- "$KITTY_INSTALLATION_DIR"/shell-integration/zsh/kitty-integration
  kitty-integration
  unfunction kitty-integration
fi

# Init secrets, tokens, etc.
if [ -f "$HOME/.env" ]; then
  source "$HOME/.env"
fi

# Init cheat sheets CLI.
eval "$(navi widget zsh)"

# Init direnv
eval "$(direnv hook zsh)"
