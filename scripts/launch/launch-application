#!/usr/bin/env sh
#
# FZF APPLICATION LAUNCHER
#
# Opens new terminal window listing applications with fzf, and launches selected application with
# swaymsg exec.
#
# Entirely based on fzf-startify by ldelossa. Rewritten for NixOS support, POSIX and shfmt compliance, ANSI
# colored output, and improved readability.
#
# https://github.com/ldelossa/sway-fzfify
#

#
# CONSTANTS
#

SCRIPT="$0"
BOLD="\e[1m"
BLUE="\e[34m"
BLACK="\e[30m"
ITALIC="\e[3m"
NORMAL="\e[0m"

#
# OPTIONS
#

# Behavior
skip_duplicates="true" # Decreases performance significantly if enabled (using cache is required)
show_description="true" # Show generic name, decreases performance slightly if enabled
show_type="true" # Show type of all (OS vs Flatpak), decreases performance slightly if enabled
use_cache="true" # Increases performance significantly (clear cache on Ctrl-C)

# Files
cache="$HOME/.cache/launch-application"

# Terminal
terminal="kitty"
class="fuzzyterm"
title="fuzzyterm"
opacity="0.9"
clipboard="wl-copy"

# Styles
namestyle="$BOLD$BLUE"
descstyle="$ITALIC$BLACK"
typestyle="$BLACK"

#
# LAUNCHER
#

# If LAUNCHER_FIFO is set then show launcher, otherwise rerun in new terminal window. Boilerplate
# for setting window title and class is handled by the script itself, so we can run or bind it by
# name, i.e. `launch-app` rather than `kitty --class launch --title Launch -- sh -c launch-app`.
if [ "$LAUNCHER_FIFO" != "" ]; then
  entries="" # Items mapped to commands, e.g. "Firefox (Web Browser):firefox\n ..."

  # Check for cached menu items
  if [ "$use_cache" = "true" ] && [ -f "$cache" ]; then
    entries="$(cat "$cache")"
  else
    # Find .desktop files
    for path in $(printf "%s" "$XDG_DATA_DIRS" | tr ':' '\n' | xargs -- fd . -e desktop -tx -tl 2>/dev/null); do
      unset flatpak

      if [ "${path#*"exports/share/applications"}" != "$path" ]; then
        flatpak="true"
      fi

      # Get .desktop file contents and use grep with Perl expressions to find application name,
      # description, and command stripped of any field codes such as %U, Flatpak codes like @@, and
      # surrounding quotes. We make an ANSI colored label to pass to fzf.
      content="$(cat "$path")"
      cmd="$(printf "%s" "$content" | grep -Po -m 1 -e "(?<=^Exec=).*")"
      name="$(printf "%s" "$content" | grep -Po -m 1 -e "(?<=^Name=).*")"
      label="$namestyle$name$NORMAL"

      # Skip duplicates
      if [ "$skip_duplicates" = "true" ] && [ "${entries#*"$path"}" != "$entries" ]; then
        continue
      elif [ "$cmd" = "" ]; then
        continue
      fi

      # Add generic name
      if [ "$show_description" = "true" ]; then
        generic="$(printf "%s" "$content" | grep -Po -m 1 -e "(?<=^GenericName=).*")"

        if [ "$generic" != "" ]; then
          label="$label ($descstyle$generic$NORMAL)"
          name="$name ($generic)"
        fi
      fi

      # Add application type
      if [ "$show_type" = "true" ]; then
        if [ "$flatpak" != "" ]; then
          label="$label$typestyle [Flatpak]$NORMAL"
          name="$name [Flatpak]"
        else
          label="$label$typestyle [Nix]$NORMAL"
          name="$name [Nix]"
        fi
      fi

      # Yank command to clipboard if the yank argument matches the generated name
      if [ "$1" = "yank" ] && [ "$2" = "$name" ]; then
        printf "%s" "$cmd" | "$clipboard"
        exit 0
      fi

      entries="$label\t$cmd\n$entries"
    done

    # Cache menu items
    if [ "$use_cache" = "true" ]; then
      printf "%b" "$entries" >"$cache"
    fi
  fi

  # Show menu and get selection with parenthesis and brackets escaped (for grep)
  selection="$(printf "%b" "$entries" | fzf --delimiter="\t" --with-nth=1 --preview-window=":hidden" --preview="echo {2}" --color="bg+:-1" --ansi --cycle --no-info --prompt "› " --pointer "➔ " --marker "» " --bind "tab:down,btab:up,alt-p:toggle-preview,ctrl-u:half-page-up,ctrl-d:half-page-down,ctrl-c:execute-silent(rm $cache)+abort,ctrl-y:execute-silent(wl-copy {2})+abort" | sed 's,[][()\.^$\/?*+],\\&,g')"

  # If selection is not empty, launch mapped command
  if [ "$selection" != "" ]; then
    # Remove escape sequences from entries and find mapped command
    cmd="$(printf "%b" "$entries" | sed 's,\x1B\[[0-9;]*[a-zA-Z],,g' | grep -Pwo -m 1 -e "(?<=^$selection:).*" | sed 's,%.,,g' | sed 's,^"\(.*\)"$,\1,g' | sed 's,@@.*@@,,g')"

    # Run the command associated with the entry (using `swaymsg exec` if possible)
    if [ -x "$(command -v swaymsg)" ]; then
      # Found swaymsg: use it to keep process alive after the shell exits
      swaymsg -t command exec "$cmd"
    elif [ -x "$(command -v bash)" ]; then
      # Found bash: use disown built-in to keep process alive after the shell exits
      nohup bash -c "nohup \"$cmd\" < /dev/null & disown" &
      sleep 0.1
    else
      # No swaymsg or bash: use nohup to keep process alive after the shell exits
      nohup "$cmd" </dev/null &
      sleep 0.1
    fi
  fi

  exit 0
fi

#
# INITIALIZE
#

# Create named pipe for search results
LAUNCHER_FIFO="$(mktemp -d)/results"
mkfifo -m 600 "$LAUNCHER_FIFO"

# Rerun in new terminal window
"$terminal" \
  --title "$title" \
  --class "$class" \
  --override "background_opacity=$opacity" \
  --override "adjust_line_height=200%" \
  -e \
  sh -c "LAUNCHER_FIFO=$LAUNCHER_FIFO $SCRIPT"
