#!/usr/bin/env sh
#
# DESCRIPTION
#   Application launcher menu. Re-launches in a new terminal window to make it easy to invoke via
#   key binds. Custom window title and class specified under options makes styling and setup simple.
#
#   The script finds and parses .desktop files and displays the results in a `fzf` menu for
#   selection. If an application is selected, the associated `Exec` command is executed. Uses
#   `riverctl` or `swaymsg` if available and otherwise good old background execution.
#
# CREDIT
#   Based on ldelossa's `sway-fzfify`, edited for NixOS, POSIX, ANSI coloring, and shfmt formatting.
#   See: https://github.com/ldelossa/sway-fzfify
#
# AUTHOR
#   Daniel Nordstrom <d@mrnordstrom.com>
#
# VERSION
#   0.1.0
#
# LICENSE
#   MIT License
#
#   Copyright (c) 2022 Daniel Nordstrom
#
#   Permission is hereby granted, free of charge, to any person obtaining a copy of this software
#   and associated documentation files (the "Software"), to deal in the Software without
#   restriction, including without limitation the rights to use, copy, modify, merge, publish,
#   distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the
#   Software is furnished to do so, subject to the following conditions:
#
#   The above copyright notice and this permission notice shall be included in all copies or
#   substantial portions of the Software.
#
#   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
#   BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
#   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
#   DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
#   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#

#
# HELPERS
#

script="$0"
bold="\e[1m"
blue="\e[34m"
black="\e[30m"
italic="\e[3m"
normal="\e[0m"

#
# OPTIONS
#

# Behavior
cache_enabled=true                             # Enable caching (Ctrl-C to clear)
cache_menu_file="$HOME/.cache/launch-app-menu" # Where to cache menu entries
cache_meta_file="$HOME/.cache/launch-app-meta" # Where to cache commands mapped to menu entries

# Terminal
terminal="kitty"
class="fuzzyterm"
title="fuzzyterm"

# Opens new terminal window. Options overrides or other custom initialization can be done here. can
# be done here. This script calls this function with the command to run as only argument, to make
# sure it always runs in a new, customizable window.
#
# Arguments:
#   Command to run to launch menu, e.g. `LAUNCHER_FIFO=[fifo] [script path]`.
init() {
  "$terminal" --title "$title" --class "$class" \
    --override "adjust_line_height=200%" \
    --override "font_size=14" \
    --override "cursor_shape=underline" \
    -e sh -c "$1"
}

# Styles
name_style="$bold$blue"    # Name
desc_style="$italic$black" # Generic name
type_style="$black"        # Type, i.e. nixpkgs or Flatpak

#
# LAUNCHER
#

# If LAUNCHER_FIFO is set then show launcher, otherwise rerun in new terminal window. Boilerplate
# for setting window title and class is handled by the script itself, so we can run or bind it by
# name, i.e. `launch-app` rather than `kitty --class launch --title Launch -- sh -c launch-app`.
if [ -n "$LAUNCHER_FIFO" ]; then
  choices="" # Items to pass fzf, e.g. "Firefox (Web Browser)\nDolphin (File Manager)\n ..."
  entries="" # Items mapped to commands, e.g. "Firefox (Web Browser):firefox\n ..."
  paths="$(printf "%s" "$XDG_DATA_DIRS" | tr ':' '\n' | xargs -- fd . -e desktop -tx -tl 2>/dev/null)"

  # Find cache
  if [ "$cache_enabled" = "true" ] && [ -f "$cache_meta_file" ] && [ -f "$cache_menu_file" ]; then
    entries="$(cat "$cache_meta_file")"
    choices="$(cat "$cache_menu_file")"
  else
    # Find desktop files
    oldifs=$IFS
    IFS='
    '

    for path in $paths; do
      unset flatpak

      if [ "${path#*"flatpak"}" != "$path" ]; then
        flatpak="true"
      fi

      cmd="$(grep -Po -m 1 -e "(?<=^Exec=).*" <"$path")"
      name="$(grep -Po -m 1 -e "(?<=^Name=).*" <"$path")"
      label="$name_style$name$normal"
      generic="$(grep -Po -m 1 -e "(?<=^GenericName=).*" <"$path")"

      # Skip if command is empty (check duplicates with "${entries#*"$path"}" != "$entries")
      if [ "$cmd" = "" ]; then
        continue
      fi

      # Add generic name
      if [ "$generic" != "" ]; then
        label="$label ($desc_style$generic$normal)"
        name="$name ($generic)"
      fi

      # Add application type
      if [ "$flatpak" != "" ]; then
        label="$label$type_style [Flatpak]$normal"
        name="$name [Flatpak]"
      else
        label="$label$type_style [Nix]$normal"
        name="$name [Nix]"
      fi

      # Yank command to clipboard if the yank argument matches the generated name
      if [ "$1" = "yank" ] && [ "$2" = "$name" ]; then
        printf "%s" "$cmd" | wl-copy
        exit 0
      fi

      # Add the command and label to the FZF entries to display, as well as to the command lookup
      # list that maps menu items to their commands upon selection.
      entries="$name:$cmd\n$entries"
      choices="$label\t$cmd\n$choices"

      # Cache items and command mappings for instant startup. TODO: Rewrite the world in Rust.
      printf "%b" "$entries" >"$cache_meta_file"
      printf "%b" "$choices" >"$cache_menu_file"
    done

    IFS=$oldifs
  fi

  # Show menu and get selected command after removing %U, @@, and similar markers
  cmd="$(printf "%b" "$choices" | fzf --color="bg+:-1" --delimiter='\t' --with-nth=1 --ansi --cycle --no-info --prompt "› " --pointer "➔ " --marker "» " --bind "tab:down,btab:up,ctrl-u:half-page-up,ctrl-d:half-page-down,ctrl-c:execute-silent(rm $cache_meta_file $cache_menu_file)+abort,ctrl-y:execute-silent(wl-copy {2})+abort" | cut -f 2 | sed 's,%.,,g' | sed 's,^"\(.*\)"$,\1,g' | sed 's,@@.*@@,,g')"

  # If selection is not empty, launch mapped command
  if [ -n "$cmd" ]; then
    # Use specific exec/spawn command if provided, otherwise check for window manager commands.
    if [ -n "$exec" ] && [ -x "$(command -v "$exec")" ]; then
      # Found swaymsg: use it to keep process alive after the shell exits
      eval "$exec $cmd"
    elif [ "$XDG_CURRENT_DESKTOP" = "river" ] && [ -x "$(command -v riverctl)" ]; then
      # Found swaymsg: use it to keep process alive after the shell exits
      riverctl spawn "$cmd"
    elif [ "$XDG_CURRENT_DESKTOP" = "sway" ] && [ -x "$(command -v swaymsg)" ]; then
      # Found swaymsg: use it to keep process alive after the shell exits
      swaymsg -t command exec "$cmd"
    elif [ -x "$(command -v bash)" ]; then
      # Found bash: use disown built-in to keep process alive after the shell exits
      nohup bash -c "nohup \"$cmd\" < /dev/null & disown" &
      sleep 0.1
    else
      # No swaymsg or bash: use nohup to keep process alive after the shell exits
      nohup "$cmd" </dev/null &
      sleep 0.1
    fi
  fi

  exit 0
fi

#
# INITIALIZE
#

# Create named pipe for search results
fifo="$(mktemp -d)/results"
mkfifo -m 600 "$fifo"

# Rerun in new terminal window
init "LAUNCHER_FIFO=$fifo $script"
