#!/usr/bin/env sh
#
# FZF APPLICATION LAUNCHER
#
# Opens new terminal window listing commands with fzf, and runs the selected command in yet another
# terminal window.
#
# Based on the application launcher, which in turn is based on fzf-startify by ldelossa.
#

#
# CONSTANTS
#

SCRIPT="$0"
BOLD="\e[1m"
MAGENTA="\e[35m"
ITALIC="\e[3m"
NORMAL="\e[0m"

#
# OPTIONS
#

# Terminal
terminal="kitty"
shell="zsh"
class="fuzzyterm"
title="fuzzyterm"
opacity="0.9"

# Styles
namestyle="$BOLD$MAGENTA"
descstyle="$ITALIC"

#
# LAUNCHER
#

# If LAUNCHER_FIFO is set then show launcher, otherwise rerun in new terminal window. Boilerplate
# for setting window title and class is handled by the script itself, so we can run or bind it by
# name, i.e. `launch-app` rather than `kitty --class launch --title Launch -- sh -c launch-app`.
if [ -n "$LAUNCHER_FIFO" ]; then
  choices="" # Items to pass fzf, e.g. "Firefox (Web Browser)\nDolphin (File Manager)\n ..."
  entries="" # Items mapped to commands, e.g. "Firefox (Web Browser):firefox\n ..."

  # Find commands using bash's compgen built-in
  bash -c "compgen -c" >"$LAUNCHER_FIFO" &

  # Read results from pipe
  while read -r path; do
    cmd="$path"
    name="$namestyle$path$NORMAL"
    desc=""

    [ "$path" = "launch-application" ] && desc="fzf application launcher"
    [ "$path" = "waybar-reloader" ] && desc="Reloads Waybar on configuration change"
    [ "$path" = "waybar-keyboard" ] && desc="Keyboard layout script for status bar"
    [ "$path" = "nix-preview" ] && desc="Symlinks NixOS config files for preview without build"
    [ "$path" = "screensnap" ] && desc="Screenshot script using slurp"
    [ "$path" = "colorsnap" ] && desc="Color picker script using slurp"
    [ "$path" = "wofi-powermenu" ] && desc="Power menu script for wofi"
    [ "$path" = "1secmail" ] && desc="Throwaway email address generator"

    [ -n "$desc" ] && name="$name ($descstyle$desc$NORMAL)"

    entries="$name:$cmd\n$entries"
    choices="$name\n$choices"
  done <"$LAUNCHER_FIFO"

  # Show menu and get selection with parenthesis and brackets escaped (for grep)
  selection="$(printf "%b" "$choices" | fzf --color='bg+:-1' --ansi --cycle --no-info --prompt '› ' --pointer '➔ ' --marker '» ' --bind 'tab:down,btab:up,ctrl-u:half-page-up,ctrl-d:half-page-down' | sed 's,[][()\.^$\/?*+],\\&,g')"

  # If selection is not empty, launch mapped command
  if [ -n "$selection" ]; then
    # Remove escape sequences from entries and find mapped command
    cmd="$(printf "%b" "$entries" | sed 's,\x1B\[[0-9;]*[a-zA-Z],,g' | grep -Pwo -m 1 -e "(?<=^$selection:).*" | sed 's,%.,,g' | sed 's,^"\(.*\)"$,\1,g' | sed 's,@@.*@@,,g')"
    cmd="$terminal --class $class --title $title --hold -e $shell -c $cmd"

    # Run the command associated with the entry (using `swaymsg exec` if possible)
    if [ -x "$(command -v swaymsg)" ]; then
      # Found swaymsg: use it to keep process alive after the shell exits
      swaymsg -t command exec "$cmd"
    elif [ -x "$(command -v bash)" ]; then
      # Found bash: use disown built-in to keep process alive after the shell exits
      nohup bash -c "nohup \"$cmd\" < /dev/null & disown" &
      sleep 0.1
    else
      # No swaymsg or bash: use nohup to keep process alive after the shell exits
      nohup "$cmd" </dev/null &
      sleep 0.1
    fi
  fi

  exit 0
fi

#
# INITIALIZE
#

# Create named pipe for search results
LAUNCHER_FIFO="$(mktemp -d)/results"
mkfifo -m 600 "$LAUNCHER_FIFO"

# Rerun in new terminal window
"$terminal" \
  --title "$title" \
  --class "$class" \
  --override "background_opacity=$opacity" \
  -e \
  "$shell" -c "LAUNCHER_FIFO=$LAUNCHER_FIFO $SCRIPT"
