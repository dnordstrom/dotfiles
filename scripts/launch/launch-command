#!/usr/bin/env sh
#
# FZF COMMAND LAUNCHER
#
# Opens a terminal and lists available commands using `fzf`. The selected command is executed in a
# new terminal window according to the settings below.
#
# Based on the application launcher, which in turn is based on fzf-startify by ldelossa.
#

#
# CONSTANTS
#

script="$0"
bold="\e[1m"
blue="\e[34m"
normal="\e[0m"

#
# OPTIONS
#

# Behavior
use_cache="false" # Increases performance significantly (clear cache on Ctrl-C)
keep_shell="true" # Keep shell open after process exist

# Files
cache="$HOME/.cache/launch-command"

# Terminal
terminal="kitty"
terminal_shell="zsh"
launcher_title="fuzzyterm"
terminal_title="popupterm"
terminal_opacity="0.9"
clipboard="wl-copy"

# Styles
name_style="$bold$blue"

#
# LAUNCHER
#

# If LAUNCHER_FIFO is set then show launcher, otherwise rerun in new terminal window. Boilerplate
# for setting window title and class is handled by the script itself, so we can run or bind it by
# name, i.e. `launch-app` rather than `kitty --title Launch -- sh -c launch-app`.
if [ "$LAUNCHER_FIFO" != "" ]; then
  entries="" # Items to pass fzf

  # Check for cached menu items
  if [ "$use_cache" = "true" ] && [ -f "$cache" ]; then
    entries="$(cat "$cache")"
  else
    # Find commands using bash's compgen built-in
    bash -c "compgen -c" >"$LAUNCHER_FIFO" &

    # Read results from pipe
    while read -r path; do
      cmd="$path"
      name="$name_style$path$normal"
      entries="$name\n$entries"
    done <"$LAUNCHER_FIFO"

    # Cache menu items
    if [ "$use_cache" = "true" ]; then
      printf "%b" "$entries" >"$cache"
    fi
  fi

  # Show menu and get selection with parenthesis and brackets escaped (for grep)
  selection="$(printf "%b" "$entries" | fzf --color="bg+:-1" --ansi --cycle --no-info --prompt "› " --pointer "➔ " --marker "» " --bind "tab:down,btab:up,alt-p:toggle-preview,ctrl-u:half-page-up,ctrl-d:half-page-down,ctrl-c:execute-silent(rm $cache)+abort,ctrl-y:execute-silent(which {} | tr -d '\n' | $clipboard)+abort")"

  # If selection is not empty, launch mapped command
  if [ "$selection" != "" ]; then
    # Remove escape sequences from entries and find mapped command
    cmd="$(printf "%b" "$selection" | sed 's,\x1B\[[0-9;]*[a-zA-Z],,g')"

    # Run in new terminal, otionally keep shell running after process exits
    if [ "$keep_shell" = "true" ]; then
      cmd="$terminal --title $terminal_title -e $terminal_shell -c '$(which "$cmd") && $terminal_shell'"
    else
      cmd="$terminal --title $terminal_title -e $terminal_shell -c '$(which "$cmd")'"
    fi

    # Use specific exec/spawn command if provided, otherwise check for window manager commands
    if [ -n "$exec" ] && [ -x "$(command -v "$exec")" ]; then
      # Found swaymsg: use it to keep process alive after the shell exits
      eval "$exec $cmd"
    elif [ "$XDG_CURRENT_DESKTOP" = "river" ] && [ -x "$(command -v riverctl)" ]; then
      # Found swaymsg: use it to keep process alive after the shell exits
      riverctl spawn "$cmd"
    elif [ "$XDG_CURRENT_DESKTOP" = "sway" ] && [ -x "$(command -v swaymsg)" ]; then
      # Found swaymsg: use it to keep process alive after the shell exits
      swaymsg -t command exec "$cmd"
    elif [ -x "$(command -v bash)" ]; then
      # Found bash: use disown built-in to keep process alive after the shell exits
      nohup bash -c "nohup \"$cmd\" < /dev/null & disown" &
      sleep 0.1
    else
      # No swaymsg or bash: use nohup to keep process alive after the shell exits
      nohup "$cmd" </dev/null &
      sleep 0.1
    fi
  fi

  exit 0
fi

#
# INITIALIZE
#

# Create named pipe for search results
fifo="$(mktemp -d)/results"
mkfifo -m 600 "$fifo"

# Rerun in new terminal window
"$terminal" \
  --title "$launcher_title" \
  --override "background_opacity=$terminal_opacity" \
  -e \
  "$terminal_shell" -c "LAUNCHER_FIFO=$fifo $script"
